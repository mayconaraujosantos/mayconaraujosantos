 # Maycon Araujo - Senior Software Engineer

## üíº Perfil Profissional

Engenheiro de Software S√™nior com vasta experi√™ncia na concep√ß√£o, desenvolvimento e implementa√ß√£o de solu√ß√µes de backend robustas e escal√°veis, especialmente em arquiteturas de microsservi√ßos. Possuo um profundo conhecimento do ecossistema Java e suas tecnologias de ponta, com foco em construir sistemas resilientes, perform√°ticos e seguros. Minha trajet√≥ria profissional √© marcada pela lideran√ßa t√©cnica, mentoria de equipes e um compromisso constante com a qualidade do c√≥digo e as melhores pr√°ticas de desenvolvimento.

## üõ†Ô∏è Expertise T√©cnica Principal

* **Linguagens:**
    * ![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white) 11, 17, profici√™ncia em programa√ß√£o concorrente e reativa.
* **Frameworks/Bibliotecas Backend:**
    * **Spring Ecosystem:**
        * ![Spring Boot](https://img.shields.io/badge/Spring_Boot-F2F4F9?style=for-the-badge&logo=spring-boot) Spring Boot (experi√™ncia avan√ßada em configura√ß√£o e otimiza√ß√£o),
        * ![Spring Cloud](https://img.shields.io/badge/Spring_Cloud-F2F4F9?style=for-the-badge&logo=spring-cloud) Spring Cloud (Service Discovery, Configuration Management, Gateway, Circuit Breakers, Stream),
        * ![Spring Security](https://img.shields.io/badge/Spring_Security-F2F4F9?style=for-the-badge&logo=spring-security) Spring Security (implementa√ß√£o de seguran√ßa com OAuth 2.0, JWT),
        * ![Spring Data JPA](https://img.shields.io/badge/Spring_Data_JPA-F2F4F9?style=for-the-badge&logo=spring-data-jpa) Spring Data JPA (otimiza√ß√£o de queries e estrat√©gias de persist√™ncia),
        * ![Lombok](https://img.shields.io/badge/Lombok-F2F4F9?style=for-the-badge&logo=projectlombok) Lombok.
    * **Persist√™ncia:**
        * ![JPA](https://img.shields.io/badge/JPA-F2F4F9?style=for-the-badge) JPA,
        * ![Flyway](https://img.shields.io/badge/Flyway-F2F4F9?style=for-the-badge&logo=flyway) Flyway (gerenciamento de migra√ß√µes de banco de dados).
    * **Mensageria:**
        * ![Apache Kafka](https://img.shields.io/badge/Apache_Kafka-000?style=for-the-badge&logo=apache-kafka) Kafka (arquitetura, streams, conectores),
        * ![RabbitMQ](https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white) RabbitMQ (roteamento avan√ßado, confiabilidade),
        * ![Google Cloud Pub/Sub](https://img.shields.io/badge/Google_Cloud_Pub/Sub-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%231E8E3E) Pub/Sub (GCP).
    * **Cache:**
        * ![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white) Redis (estrat√©gias de cache distribu√≠do).
    * **Comunica√ß√£o:**
        * ![gRPC](https://img.shields.io/badge/gRPC-F2F4F9?style=for-the-badge&logo=grpc) gRPC.
* **Testes:**
    * ![TDD](https://img.shields.io/badge/TDD-F2F4F9?style=for-the-badge) TDD (Desenvolvimento Guiado por Testes),
    * ![JUnit](https://img.shields.io/badge/JUnit-25A18E?style=for-the-badge&logo=junit5&logoColor=white) JUnit 4/5 (cria√ß√£o de testes unit√°rios abrangentes),
    * ![BDD](https://img.shields.io/badge/BDD-F2F4F9?style=for-the-badge) BDD (Desenvolvimento Orientado a Comportamento) com
    * ![Cucumber](https://img.shields.io/badge/Cucumber-232323?style=for-the-badge&logo=cucumber&logoColor=white) Cucumber (defini√ß√£o de cen√°rios em linguagem natural).
* **Cloud Computing:**
    * ![Amazon AWS](https://img.shields.io/badge/Amazon_AWS-232F3E?style=for-the-badge&logo=amazon-aws&logoColor=white) AWS (
        * ![Amazon SQS](https://img.shields.io/badge/Amazon_SQS-FF4F00?style=for-the-badge&logo=amazon-sqs&logoColor=white) SQS,
        * ![Amazon RDS](https://img.shields.io/badge/Amazon_RDS-0077B6?style=for-the-badge&logo=amazon-rds&logoColor=white) RDS,
        * ![Amazon SNS](https://img.shields.io/badge/Amazon_SNS-FF9900?style=for-the-badge&logo=amazon-sns&logoColor=white) SNS,
        * ![Amazon S3](https://img.shields.io/badge/Amazon_S3-569A31?style=for-the-badge&logo=amazon-s3&logoColor=white) S3,
        * ![Amazon ECR](https://img.shields.io/badge/Amazon_ECR-00AEEF?style=for-the-badge&logo=amazon-ecr&logoColor=white) ECR,
        * ![Amazon EKS](https://img.shields.io/badge/Amazon_EKS-000?style=for-the-badge&logo=amazon-eks&logoColor=white) EKS
    ),
    * ![Google Cloud](https://img.shields.io/badge/Google_Cloud-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white) GCP (
        * ![Google Cloud Functions](https://img.shields.io/badge/Google_Cloud_Functions-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%23E91E63) Cloud Functions,
        * ![Google BigQuery](https://img.shields.io/badge/Google_BigQuery-F2F4F9?style=for-the-badge&logo=google-bigquery&logoColor=%234285F4) BigQuery
    ).
* **Containeriza√ß√£o e Orquestra√ß√£o:**
    * ![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white) Docker,
    * ![Kubernetes](https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=kubernetes&logoColor=white) Kubernetes.
* **Monitoramento e Observabilidade:**
    * ![Grafana](https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white) Grafana,
    * ![New Relic](https://img.shields.io/badge/New_Relic-00A63F?style=for-the-badge&logo=new-relic&logoColor=white) Relic,
    * ![Splunk](https://img.shields.io/badge/Splunk-000000?style=for-the-badge&logo=splunk&logoColor=white) Splunk.
* **CI/CD:**
    * ![Jenkins](https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white) Jenkins,
    * ![GitHub Actions](https://img.shields.io/badge/GitHub_Actions-2088FF?style=for-the-badge&logo=github-actions&logoColor=white) GitHub Actions,
    * ![GitLab CI](https://img.shields.io/badge/GitLab_CI-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab CI.
* **Frontend (Conhecimento):**
    * ![Angular](https://img.shields.io/badge/Angular-DD0031?style=for-the-badge&logo=angular&logoColor=white) Angular,
    * ![TypeScript](https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white) TypeScript.
* **Gerenciamento de C√≥digo:**
    * ![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white) Git,
    * ![GitLab](https://img.shields.io/badge/GitLab-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab,
    * ![GitFlow](https://img.shields.io/badge/GitFlow-F2F4F9?style=for-the-badge) GitFlow.
* **Gerenciamento de Projetos:**
    * ![Jira](https://img.shields.io/badge/Jira-0052CC?style=for-the-badge&logo=jira&logoColor=white) Jira,
    * ![Scrum](https://img.shields.io/badge/Scrum-F2F4F9?style=for-the-badge) Scrum.

## üí° Experi√™ncia Profissional

Minha experi√™ncia abrange a lideran√ßa t√©cnica e a contribui√ß√£o individual em projetos complexos, incluindo:

* **Desenvolvimento e evolu√ß√£o de plataformas de microsservi√ßos** utilizando Spring Boot e Spring Cloud, garantindo alta escalabilidade e resili√™ncia.
* **Implementa√ß√£o de solu√ß√µes de mensageria robustas** com Kafka e RabbitMQ para comunica√ß√£o ass√≠ncrona e processamento de eventos em larga escala.
* **Desenvolvimento de APIs RESTful seguras e perform√°ticas** com Spring Security, seguindo as melhores pr√°ticas de design e documenta√ß√£o.
* **Utiliza√ß√£o extensiva de bancos de dados relacionais (JPA, Flyway) e NoSQL (Redis)**, com foco em otimiza√ß√£o de performance e modelagem de dados eficiente.
* **Implementa√ß√£o de testes automatizados em todas as camadas (unit√°rios, integra√ß√£o, BDD)** para garantir a qualidade e a estabilidade do software.
* **Experi√™ncia pr√°tica com plataformas de cloud (AWS e GCP)**, incluindo a utiliza√ß√£o de servi√ßos como SQS, RDS, SNS, S3, ECR, EKS, Cloud Functions e BigQuery.
* **Cria√ß√£o e gerenciamento de pipelines de CI/CD** com Jenkins e GitHub Actions para automatizar o processo de entrega de software.
* **Monitoramento e an√°lise de sistemas em produ√ß√£o** utilizando Grafana, Relic e Splunk para identificar e solucionar problemas proativamente.
* **Colabora√ß√£o em equipes multidisciplinares utilizando a metodologia Scrum e ferramentas como Jira.**
* **Mentoria de desenvolvedores juniores e plenos, compartilhando conhecimento e promovendo o crescimento t√©cnico.**

*(Aqui voc√™ pode adicionar detalhes mais espec√≠ficos sobre seus projetos e responsabilidades em cada experi√™ncia profissional, se desejar.)*

## üî≠ Projetos Pessoais e Contribui√ß√µes

* **[Nome do Projeto Pessoal 1](Link do Projeto 1):** Breve descri√ß√£o do projeto, destacando as tecnologias avan√ßadas utilizadas (ex: arquitetura reativa com Spring WebFlux e Kafka Streams).
* **[Nome do Projeto Pessoal 2](Link do Projeto 2):** Contribui√ß√£o significativa para algum projeto Open Source relevante em alguma das tecnologias listadas.
* **[Nome do Projeto Pessoal 3](Link do Projeto 3):** Demonstra√ß√£o de habilidades espec√≠ficas em alguma tecnologia (ex: implementa√ß√£o de um sistema de filas distribu√≠das com RabbitMQ com padr√µes de confiabilidade).

*(Inclua links para seus projetos mais relevantes no GitHub ou outras plataformas.)*

## ü§ù Conecte-se

* [LinkedIn](https://www.linkedin.com/in/maycon-araujo/)
* [GitHub](Seu Link do GitHub)
* [Seu Email Profissional]

## ‚ö° Interesses

* Explora√ß√£o de novas tecnologias e tend√™ncias no desenvolvimento de software.
* Participa√ß√£o em comunidades t√©cnicas e compartilhamento de conhecimento.
* Busca cont√≠nua por aprimoramento em arquiteturas de sistemas distribu√≠dos e escal√°veis.

Agrade√ßo o seu interesse em meu perfil. Estou sempre aberto a novas oportunidades e desafios que me permitam aplicar e expandir minhas habilidades. 

```kotlin
class EscrowAccountGatewayDAImplTest {

  private lateinit var escrowAccountGateway: EscrowAccountGateway
  private lateinit var escrowAccountGatewayDAImpl: EscrowAccountGatewayDAImpl

  @BeforeEach
  fun setup() {
    escrowAccountGateway = mockk()
    escrowAccountGatewayDAImpl = EscrowAccountGatewayDAImpl(escrowAccountGateway)
  }

  @Test
  fun `should create new escrow account successfully`() {
    // Given
    val expectedResponse = EscrowAccountTestUtils.loadCreateSuccessResponse()
    every { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) } returns
            expectedResponse

    // When
    val result = escrowAccountGatewayDAImpl.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)

    // Then
    assertEquals(expectedResponse, result)
    verify { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) }
  }

  @Test
  fun `should throw exception on create escrow account failure with 400`() {
    // Given
    val expectedException = EscrowAccountTestUtils.createBadRequestException()
    every { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) } throws
            expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
    }
    verify { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) }
  }

  @Test
  fun `should throw exception on create escrow account failure with 500`() {
    // Given
    val expectedException = EscrowAccountTestUtils.createInternalServerErrorException()
    every { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) } throws
            expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
    }
    verify { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) }
  }

  @Test
  fun `should throw exception on create escrow account failure with 401`() {
    // Given
    val expectedException = EscrowAccountTestUtils.createUnauthorizedException()
    every { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) } throws
            expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
    }
    verify { escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID) }
  }

  @Test
  fun `should cancel escrow account successfully`() {
    // Given
    val expectedResponse = EscrowAccountTestUtils.loadCancelSuccessResponse()
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    every { escrowAccountGateway.cancelEscrowAccount(cancelRequest) } returns expectedResponse

    // When
    val result = escrowAccountGatewayDAImpl.cancelEscrowAccount(cancelRequest)

    // Then
    assertEquals(expectedResponse, result)
    verify { escrowAccountGateway.cancelEscrowAccount(cancelRequest) }
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 400`() {
    // Given
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    val expectedException = EscrowAccountTestUtils.createBadRequestException()
    every { escrowAccountGateway.cancelEscrowAccount(cancelRequest) } throws expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.cancelEscrowAccount(cancelRequest)
    }
    verify { escrowAccountGateway.cancelEscrowAccount(cancelRequest) }
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 500`() {
    // Given
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    val expectedException = EscrowAccountTestUtils.createInternalServerErrorException()
    every { escrowAccountGateway.cancelEscrowAccount(cancelRequest) } throws expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.cancelEscrowAccount(cancelRequest)
    }
    verify { escrowAccountGateway.cancelEscrowAccount(cancelRequest) }
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 401`() {
    // Given
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    val expectedException = EscrowAccountTestUtils.createUnauthorizedException()
    every { escrowAccountGateway.cancelEscrowAccount(cancelRequest) } throws expectedException

    // When & Then
    assertExceptionThrown(expectedException) {
      escrowAccountGatewayDAImpl.cancelEscrowAccount(cancelRequest)
    }
    verify { escrowAccountGateway.cancelEscrowAccount(cancelRequest) }
  }

  private fun assertExceptionThrown(
          expectedException: EscrowAccountGatewayException,
          block: () -> Unit
  ) {
    val exception = assertThrows<EscrowAccountGatewayException> { block() }
    assertEquals(expectedException.message, exception.message)
    assertEquals(expectedException.statusCode, exception.statusCode)
  }
}
```

```kotlin 
class EscrowAccountGatewayTest {

  private lateinit var escrowAccountGateway: EscrowAccountGateway

  @BeforeEach
  fun setup() {
    escrowAccountGateway =
            EscrowAccountGateway(
                    EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG,
                    EscrowAccountTestUtils.objectMapper
            )
  }

  @AfterEach
  fun tearDown() {
    FuelManager.instance.client = FuelManager.instance.client
  }

  @Test
  fun `should create new escrow account successfully`() {
    // Given
    val (responseBody, expectedResponse) = EscrowAccountTestUtils.getCreateSuccessData()
    EscrowAccountTestUtils.mockSuccessfulResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/${EscrowAccountTestUtils.PERSON_ID}/create",
            responseBody
    )

    // When
    val result = escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)

    // Then
    assertEquals(expectedResponse, result)
  }

  @Test
  fun `should throw exception on create escrow account failure with 400`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getBadRequestErrorData()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/${EscrowAccountTestUtils.PERSON_ID}/create",
            HttpStatus.BAD_REQUEST.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
            }
    assertEquals(expectedException.message, exception.message)
    assertEquals(expectedException.statusCode, exception.statusCode)
  }

  @Test
  fun `should throw exception on create escrow account failure with 500`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getInternalServerErrorData()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/${EscrowAccountTestUtils.PERSON_ID}/create",
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
            }
    assertEquals(expectedException.message, exception.message)
    assertEquals(expectedException.statusCode, exception.statusCode)
  }

  @Test
  fun `should throw exception on create escrow account failure with 401`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getUnauthorizedErrorData()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/${EscrowAccountTestUtils.PERSON_ID}/create",
            HttpStatus.UNAUTHORIZED.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.createNewEscrowAccount(EscrowAccountTestUtils.PERSON_ID)
            }
    assertEquals(expectedException.message, exception.message)
    assertEquals(expectedException.statusCode, exception.statusCode)
  }

  @Test
  fun `should cancel escrow account successfully`() {
    // Given
    val (responseBody, expectedResponse) = EscrowAccountTestUtils.getCancelSuccessData()
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    EscrowAccountTestUtils.mockSuccessfulResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/cancel",
            responseBody
    )

    // When
    val result = escrowAccountGateway.cancelEscrowAccount(cancelRequest)

    // Then
    assertEquals(expectedResponse, result)
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 400`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getBadRequestErrorData()
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/cancel",
            HttpStatus.BAD_REQUEST.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.cancelEscrowAccount(cancelRequest)
            }
    assertEquals(
            EscrowAccountTestUtils.createCancelBadRequestException().message,
            exception.message
    )
    assertEquals(expectedException.statusCode, exception.statusCode)
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 500`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getInternalServerErrorData()
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/cancel",
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.cancelEscrowAccount(cancelRequest)
            }
    assertEquals(
            EscrowAccountTestUtils.createCancelInternalServerErrorException().message,
            exception.message
    )
    assertEquals(expectedException.statusCode, exception.statusCode)
  }

  @Test
  fun `should throw exception on cancel escrow account failure with 401`() {
    // Given
    val (errorBody, expectedException) = EscrowAccountTestUtils.getUnauthorizedErrorData()
    val cancelRequest = EscrowAccountTestUtils.createEscrowAccountCancelDto()
    EscrowAccountTestUtils.mockErrorResponse(
            "${EscrowAccountTestUtils.TEST_ESCROW_ACCOUNT_CONFIG.apiUrl}/escrow-accounts/cancel",
            HttpStatus.UNAUTHORIZED.value(),
            errorBody
    )

    // When & Then
    val exception =
            assertThrows<EscrowAccountGatewayException> {
              escrowAccountGateway.cancelEscrowAccount(cancelRequest)
            }
    assertEquals(
            EscrowAccountTestUtils.createCancelUnauthorizedException().message,
            exception.message
    )
    assertEquals(expectedException.statusCode, exception.statusCode)
  }
}
```


```kotlin
object EscrowAccountTestUtils {

  // Constants
  const val PERSON_ID = "01E840YMYP0WXY1DTSQGCX05S5"
  const val ACCOUNT_ID = "123456789"
  const val ACCOUNT_NUMBER = "123456"
  const val ACCOUNT_BRANCH = "1"
  const val CONTRACT_NUMBER = "0200000123"
  const val BLOCKING_ID = 53
  const val BLOCKING_REASON = "Test reason"
  const val ACCOUNT_ALREADY_MONITORED_MESSAGE = "Account already being monitored"
  const val ACCOUNT_NOT_FOUND_MESSAGE = "Account not found"
  const val INTERNAL_SERVER_ERROR_MESSAGE = "Internal server error"
  const val UNAUTHORIZED_MESSAGE = "Unauthorized"

  // Configuration
  val TEST_ESCROW_ACCOUNT_CONFIG =
          EscrowAccountConfig(
                  apiUrl = "https://api.test.com",
                  authToken = "Bearer test-token",
                  apiTimeout = 5000,
                  blockingId = BLOCKING_ID,
                  blockingReason = BLOCKING_REASON
          )

  // ObjectMapper instance configured like the application
  val objectMapper =
          jacksonObjectMapper().apply {
            this.propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE
            this.registerKotlinModule()
            this.configure(
                    com.fasterxml.jackson.databind.DeserializationFeature
                            .FAIL_ON_UNKNOWN_PROPERTIES,
                    false
            )
          }

  // DTO creation helpers
  fun createEscrowAccountCancelDto(): EscrowAccountCancelDto {
    return EscrowAccountCancelDto().apply {
      accountId = ACCOUNT_ID
      branch = ACCOUNT_BRANCH
      accountNumber = ACCOUNT_NUMBER
      contractNumber = CONTRACT_NUMBER
      applyBlock = false
      blockingId = BLOCKING_ID
      blockingReason = BLOCKING_REASON
    }
  }

  fun loadEscrowAccountCreationDto(responseFile: String): EscrowAccountCreationDto {
    val responseBody = ResponseUtils.getResource(responseFile)
    return objectMapper.readValue(responseBody, EscrowAccountCreationDto::class.java)
  }

  fun loadEscrowAccountCancelDto(responseFile: String): EscrowAccountCancelDto {
    val responseBody = ResponseUtils.getResource(responseFile)
    return objectMapper.readValue(responseBody, EscrowAccountCancelDto::class.java)
  }

  // Exception creation helpers
  fun createExceptionFromErrorResponse(
          errorFile: String,
          statusCode: Int
  ): EscrowAccountGatewayException {
    val errorBody = ResponseUtils.getResource(errorFile)
    val url = "https://api.test.com/escrow-accounts/01E840YMYP0WXY1DTSQGCX05S5/create"
    val message = "Request to $url failed with status code $statusCode. Raw response: $errorBody"
    return EscrowAccountGatewayException(message, statusCode)
  }

  fun createBadRequestException(): EscrowAccountGatewayException {
    return createExceptionFromErrorResponse(
            "responses/escrow-account/bad_request_400.json",
            HttpStatus.BAD_REQUEST.value()
    )
  }

  fun createInternalServerErrorException(): EscrowAccountGatewayException {
    return createExceptionFromErrorResponse(
            "responses/escrow-account/internal_server_error_500.json",
            HttpStatus.INTERNAL_SERVER_ERROR.value()
    )
  }

  fun createUnauthorizedException(): EscrowAccountGatewayException {
    return createExceptionFromErrorResponse(
            "responses/escrow-account/unauthorized_401.json",
            HttpStatus.UNAUTHORIZED.value()
    )
  }

  // Exception creation helpers for cancel operations (different URL)
  fun createCancelBadRequestException(): EscrowAccountGatewayException {
    val errorBody = ResponseUtils.getResource("responses/escrow-account/bad_request_400.json")
    val url = "https://api.test.com/escrow-accounts/cancel"
    val message =
            "Request to $url failed with status code ${HttpStatus.BAD_REQUEST.value()}. Raw response: $errorBody"
    return EscrowAccountGatewayException(message, HttpStatus.BAD_REQUEST.value())
  }

  fun createCancelInternalServerErrorException(): EscrowAccountGatewayException {
    val errorBody =
            ResponseUtils.getResource("responses/escrow-account/internal_server_error_500.json")
    val url = "https://api.test.com/escrow-accounts/cancel"
    val message =
            "Request to $url failed with status code ${HttpStatus.INTERNAL_SERVER_ERROR.value()}. Raw response: $errorBody"
    return EscrowAccountGatewayException(message, HttpStatus.INTERNAL_SERVER_ERROR.value())
  }

  fun createCancelUnauthorizedException(): EscrowAccountGatewayException {
    val errorBody = ResponseUtils.getResource("responses/escrow-account/unauthorized_401.json")
    val url = "https://api.test.com/escrow-accounts/cancel"
    val message =
            "Request to $url failed with status code ${HttpStatus.UNAUTHORIZED.value()}. Raw response: $errorBody"
    return EscrowAccountGatewayException(message, HttpStatus.UNAUTHORIZED.value())
  }

  // Response loading helpers
  fun loadCreateSuccessResponse(): EscrowAccountCreationDto {
    return loadEscrowAccountCreationDto("responses/escrow-account/create_success_200.json")
  }

  fun loadCancelSuccessResponse(): EscrowAccountCancelDto {
    return loadEscrowAccountCancelDto("responses/escrow-account/cancel_success_200.json")
  }

  // Combined helpers to avoid duplication
  fun getCreateSuccessData(): Pair<String, EscrowAccountCreationDto> {
    val json = ResponseUtils.getResource("responses/escrow-account/create_success_200.json")
    val dto = objectMapper.readValue(json, EscrowAccountCreationDto::class.java)
    return Pair(json, dto)
  }

  fun getCancelSuccessData(): Pair<String, EscrowAccountCancelDto> {
    val json = ResponseUtils.getResource("responses/escrow-account/cancel_success_200.json")
    val dto = objectMapper.readValue(json, EscrowAccountCancelDto::class.java)
    return Pair(json, dto)
  }

  fun getBadRequestErrorData(): Pair<String, EscrowAccountGatewayException> {
    val json = ResponseUtils.getResource("responses/escrow-account/bad_request_400.json")
    val exception = createBadRequestException()
    return Pair(json, exception)
  }

  fun getInternalServerErrorData(): Pair<String, EscrowAccountGatewayException> {
    val json = ResponseUtils.getResource("responses/escrow-account/internal_server_error_500.json")
    val exception = createInternalServerErrorException()
    return Pair(json, exception)
  }

  fun getUnauthorizedErrorData(): Pair<String, EscrowAccountGatewayException> {
    val json = ResponseUtils.getResource("responses/escrow-account/unauthorized_401.json")
    val exception = createUnauthorizedException()
    return Pair(json, exception)
  }

  // Mock helpers
  fun mockErrorResponse(url: String, statusCode: Int, errorBody: String) {
    val body =
            mockk<Body> {
              every { toByteArray() } returns errorBody.toByteArray()
              every { toStream() } returns errorBody.toByteArray().inputStream()
            }
    val client =
            mockk<com.github.kittinunf.fuel.core.Client> {
              every { executeRequest(any()) } returns
                      com.github.kittinunf.fuel.core.Response(
                              url = URL(url),
                              statusCode = statusCode,
                              body = body,
                              headers = loadHeaders()
                      )
            }
    FuelManager.instance.client = client
  }

  fun mockSuccessfulResponse(url: String, responseBody: String) {
    val body =
            mockk<Body> {
              every { toByteArray() } returns responseBody.toByteArray()
              every { toStream() } returns responseBody.toByteArray().inputStream()
            }
    val client =
            mockk<com.github.kittinunf.fuel.core.Client> {
              every { executeRequest(any()) } returns
                      com.github.kittinunf.fuel.core.Response(
                              url = URL(url),
                              statusCode = HttpStatus.OK.value(),
                              body = body,
                              headers = loadHeaders()
                      )
            }
    FuelManager.instance.client = client
  }

  private fun loadHeaders(): Headers {
    return Headers().apply {
      append("Content-Type", "application/json")
      append("Authorization", TEST_ESCROW_ACCOUNT_CONFIG.authToken)
    }
  }
}

```

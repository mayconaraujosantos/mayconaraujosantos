# Maycon Araujo - Senior Software Engineer

## üíº Perfil Profissional

Engenheiro de Software S√™nior com vasta experi√™ncia na concep√ß√£o, desenvolvimento e implementa√ß√£o de solu√ß√µes de backend robustas e escal√°veis, especialmente em arquiteturas de microsservi√ßos. Possuo um profundo conhecimento do ecossistema Java e suas tecnologias de ponta, com foco em construir sistemas resilientes, perform√°ticos e seguros. Minha trajet√≥ria profissional √© marcada pela lideran√ßa t√©cnica, mentoria de equipes e um compromisso constante com a qualidade do c√≥digo e as melhores pr√°ticas de desenvolvimento.

## üõ†Ô∏è Expertise T√©cnica Principal

* **Linguagens:**
    * ![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white) 11, 17, profici√™ncia em programa√ß√£o concorrente e reativa.
* **Frameworks/Bibliotecas Backend:**
    * **Spring Ecosystem:**
        * ![Spring Boot](https://img.shields.io/badge/Spring_Boot-F2F4F9?style=for-the-badge&logo=spring-boot) Spring Boot (experi√™ncia avan√ßada em configura√ß√£o e otimiza√ß√£o),
        * ![Spring Cloud](https://img.shields.io/badge/Spring_Cloud-F2F4F9?style=for-the-badge&logo=spring-cloud) Spring Cloud (Service Discovery, Configuration Management, Gateway, Circuit Breakers, Stream),
        * ![Spring Security](https://img.shields.io/badge/Spring_Security-F2F4F9?style=for-the-badge&logo=spring-security) Spring Security (implementa√ß√£o de seguran√ßa com OAuth 2.0, JWT),
        * ![Spring Data JPA](https://img.shields.io/badge/Spring_Data_JPA-F2F4F9?style=for-the-badge&logo=spring-data-jpa) Spring Data JPA (otimiza√ß√£o de queries e estrat√©gias de persist√™ncia),
        * ![Lombok](https://img.shields.io/badge/Lombok-F2F4F9?style=for-the-badge&logo=projectlombok) Lombok.
    * **Persist√™ncia:**
        * ![JPA](https://img.shields.io/badge/JPA-F2F4F9?style=for-the-badge) JPA,
        * ![Flyway](https://img.shields.io/badge/Flyway-F2F4F9?style=for-the-badge&logo=flyway) Flyway (gerenciamento de migra√ß√µes de banco de dados).
    * **Mensageria:**
        * ![Apache Kafka](https://img.shields.io/badge/Apache_Kafka-000?style=for-the-badge&logo=apache-kafka) Kafka (arquitetura, streams, conectores),
        * ![RabbitMQ](https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white) RabbitMQ (roteamento avan√ßado, confiabilidade),
        * ![Google Cloud Pub/Sub](https://img.shields.io/badge/Google_Cloud_Pub/Sub-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%231E8E3E) Pub/Sub (GCP).
    * **Cache:**
        * ![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white) Redis (estrat√©gias de cache distribu√≠do).
    * **Comunica√ß√£o:**
        * ![gRPC](https://img.shields.io/badge/gRPC-F2F4F9?style=for-the-badge&logo=grpc) gRPC.
* **Testes:**
    * ![TDD](https://img.shields.io/badge/TDD-F2F4F9?style=for-the-badge) TDD (Desenvolvimento Guiado por Testes),
    * ![JUnit](https://img.shields.io/badge/JUnit-25A18E?style=for-the-badge&logo=junit5&logoColor=white) JUnit 4/5 (cria√ß√£o de testes unit√°rios abrangentes),
    * ![BDD](https://img.shields.io/badge/BDD-F2F4F9?style=for-the-badge) BDD (Desenvolvimento Orientado a Comportamento) com
    * ![Cucumber](https://img.shields.io/badge/Cucumber-232323?style=for-the-badge&logo=cucumber&logoColor=white) Cucumber (defini√ß√£o de cen√°rios em linguagem natural).
* **Cloud Computing:**
    * ![Amazon AWS](https://img.shields.io/badge/Amazon_AWS-232F3E?style=for-the-badge&logo=amazon-aws&logoColor=white) AWS (
        * ![Amazon SQS](https://img.shields.io/badge/Amazon_SQS-FF4F00?style=for-the-badge&logo=amazon-sqs&logoColor=white) SQS,
        * ![Amazon RDS](https://img.shields.io/badge/Amazon_RDS-0077B6?style=for-the-badge&logo=amazon-rds&logoColor=white) RDS,
        * ![Amazon SNS](https://img.shields.io/badge/Amazon_SNS-FF9900?style=for-the-badge&logo=amazon-sns&logoColor=white) SNS,
        * ![Amazon S3](https://img.shields.io/badge/Amazon_S3-569A31?style=for-the-badge&logo=amazon-s3&logoColor=white) S3,
        * ![Amazon ECR](https://img.shields.io/badge/Amazon_ECR-00AEEF?style=for-the-badge&logo=amazon-ecr&logoColor=white) ECR,
        * ![Amazon EKS](https://img.shields.io/badge/Amazon_EKS-000?style=for-the-badge&logo=amazon-eks&logoColor=white) EKS
    ),
    * ![Google Cloud](https://img.shields.io/badge/Google_Cloud-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white) GCP (
        * ![Google Cloud Functions](https://img.shields.io/badge/Google_Cloud_Functions-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%23E91E63) Cloud Functions,
        * ![Google BigQuery](https://img.shields.io/badge/Google_BigQuery-F2F4F9?style=for-the-badge&logo=google-bigquery&logoColor=%234285F4) BigQuery
    ).
* **Containeriza√ß√£o e Orquestra√ß√£o:**
    * ![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white) Docker,
    * ![Kubernetes](https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=kubernetes&logoColor=white) Kubernetes.
* **Monitoramento e Observabilidade:**
    * ![Grafana](https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white) Grafana,
    * ![New Relic](https://img.shields.io/badge/New_Relic-00A63F?style=for-the-badge&logo=new-relic&logoColor=white) Relic,
    * ![Splunk](https://img.shields.io/badge/Splunk-000000?style=for-the-badge&logo=splunk&logoColor=white) Splunk.
* **CI/CD:**
    * ![Jenkins](https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white) Jenkins,
    * ![GitHub Actions](https://img.shields.io/badge/GitHub_Actions-2088FF?style=for-the-badge&logo=github-actions&logoColor=white) GitHub Actions,
    * ![GitLab CI](https://img.shields.io/badge/GitLab_CI-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab CI.
* **Frontend (Conhecimento):**
    * ![Angular](https://img.shields.io/badge/Angular-DD0031?style=for-the-badge&logo=angular&logoColor=white) Angular,
    * ![TypeScript](https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white) TypeScript.
* **Gerenciamento de C√≥digo:**
    * ![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white) Git,
    * ![GitLab](https://img.shields.io/badge/GitLab-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab,
    * ![GitFlow](https://img.shields.io/badge/GitFlow-F2F4F9?style=for-the-badge) GitFlow.
* **Gerenciamento de Projetos:**
    * ![Jira](https://img.shields.io/badge/Jira-0052CC?style=for-the-badge&logo=jira&logoColor=white) Jira,
    * ![Scrum](https://img.shields.io/badge/Scrum-F2F4F9?style=for-the-badge) Scrum.

## üí° Experi√™ncia Profissional

Minha experi√™ncia abrange a lideran√ßa t√©cnica e a contribui√ß√£o individual em projetos complexos, incluindo:

* **Desenvolvimento e evolu√ß√£o de plataformas de microsservi√ßos** utilizando Spring Boot e Spring Cloud, garantindo alta escalabilidade e resili√™ncia.
* **Implementa√ß√£o de solu√ß√µes de mensageria robustas** com Kafka e RabbitMQ para comunica√ß√£o ass√≠ncrona e processamento de eventos em larga escala.
* **Desenvolvimento de APIs RESTful seguras e perform√°ticas** com Spring Security, seguindo as melhores pr√°ticas de design e documenta√ß√£o.
* **Utiliza√ß√£o extensiva de bancos de dados relacionais (JPA, Flyway) e NoSQL (Redis)**, com foco em otimiza√ß√£o de performance e modelagem de dados eficiente.
* **Implementa√ß√£o de testes automatizados em todas as camadas (unit√°rios, integra√ß√£o, BDD)** para garantir a qualidade e a estabilidade do software.
* **Experi√™ncia pr√°tica com plataformas de cloud (AWS e GCP)**, incluindo a utiliza√ß√£o de servi√ßos como SQS, RDS, SNS, S3, ECR, EKS, Cloud Functions e BigQuery.
* **Cria√ß√£o e gerenciamento de pipelines de CI/CD** com Jenkins e GitHub Actions para automatizar o processo de entrega de software.
* **Monitoramento e an√°lise de sistemas em produ√ß√£o** utilizando Grafana, Relic e Splunk para identificar e solucionar problemas proativamente.
* **Colabora√ß√£o em equipes multidisciplinares utilizando a metodologia Scrum e ferramentas como Jira.**
* **Mentoria de desenvolvedores juniores e plenos, compartilhando conhecimento e promovendo o crescimento t√©cnico.**

*(Aqui voc√™ pode adicionar detalhes mais espec√≠ficos sobre seus projetos e responsabilidades em cada experi√™ncia profissional, se desejar.)*

## üî≠ Projetos Pessoais e Contribui√ß√µes

* **[Nome do Projeto Pessoal 1](Link do Projeto 1):** Breve descri√ß√£o do projeto, destacando as tecnologias avan√ßadas utilizadas (ex: arquitetura reativa com Spring WebFlux e Kafka Streams).
* **[Nome do Projeto Pessoal 2](Link do Projeto 2):** Contribui√ß√£o significativa para algum projeto Open Source relevante em alguma das tecnologias listadas.
* **[Nome do Projeto Pessoal 3](Link do Projeto 3):** Demonstra√ß√£o de habilidades espec√≠ficas em alguma tecnologia (ex: implementa√ß√£o de um sistema de filas distribu√≠das com RabbitMQ com padr√µes de confiabilidade).

*(Inclua links para seus projetos mais relevantes no GitHub ou outras plataformas.)*

## ü§ù Conecte-se

* [LinkedIn](https://www.linkedin.com/in/maycon-araujo/)
* [GitHub](Seu Link do GitHub)
* [Seu Email Profissional]

## ‚ö° Interesses

* Explora√ß√£o de novas tecnologias e tend√™ncias no desenvolvimento de software.
* Participa√ß√£o em comunidades t√©cnicas e compartilhamento de conhecimento.
* Busca cont√≠nua por aprimoramento em arquiteturas de sistemas distribu√≠dos e escal√°veis.

Agrade√ßo o seu interesse em meu perfil. Estou sempre aberto a novas oportunidades e desafios que me permitam aplicar e expandir minhas habilidades. 



```kotlin
package com.finapp.repository

import jakarta.persistence.*
import org.hibernate.annotations.CreationTimestamp
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import java.time.LocalDate
import java.time.LocalDateTime

// Entity
@Entity
@Table(name = "card_receivables_schedules")
data class CardReceivablesSchedule(
    @Id
    @Column(length = 26)
    val id: String,

    @Column(name = "tax_identifier", length = 26, nullable = false)
    val taxIdentifier: String,

    @Column(length = 20, nullable = false)
    val register: String,

    @Column(length = 3, nullable = false)
    val arrangement: String,

    @Column(length = 20, nullable = false)
    val accreditor: String,

    @Column(length = 20, nullable = false)
    val source: String,

    @Column(name = "start_date", nullable = false)
    val startDate: LocalDate,

    @Column(name = "end_date", nullable = false)
    val endDate: LocalDate,

    @Column(columnDefinition = "jsonb", nullable = false)
    val schedules: String,

    @CreationTimestamp
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime? = null
)

// Repository
interface CardReceivablesScheduleRepository : JpaRepository<CardReceivablesSchedule, String> {
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier " +
           "AND c.startDate <= :endDate AND c.endDate >= :startDate")
    fun findByTaxIdentifierAndDateOverlap(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>

    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier " +
           "AND c.startDate BETWEEN :startDate AND :endDate")
    fun findByTaxIdentifierAndStartDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>

    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier " +
           "AND c.endDate BETWEEN :startDate AND :endDate")
    fun findByTaxIdentifierAndEndDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier LIKE :rootTaxIdentifier || '%' " +
           "AND c.startDate <= :endDate AND c.endDate >= :startDate")
    fun findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier LIKE :rootTaxIdentifier || '%' " +
           "AND c.startDate BETWEEN :startDate AND :endDate")
    fun findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>

    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier LIKE :rootTaxIdentifier || '%' " +
           "AND c.endDate BETWEEN :startDate AND :endDate")
    fun findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier " +
           "AND c.register = :register AND c.arrangement = :arrangement " +
           "AND c.accreditor = :accreditor AND c.source = :source " +
           "AND c.startDate <= :endDate AND c.endDate >= :startDate")
    fun findByCompositeKeyAndDateOverlap(
        taxIdentifier: String,
        register: String,
        arrangement: String,
        accreditor: String,
        source: String,
        startDate: LocalDate,
        endDate: LocalDate
    ): List<CardReceivablesSchedule>
}
```

```kotlin
package com.finapp.dataaccess

import com.finapp.repository.CardReceivablesSchedule
import com.finapp.repository.CardReceivablesScheduleRepository
import org.springframework.stereotype.Component

// Data Access Interface
interface CardReceivablesScheduleDataAccess {
    fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesSchedule>
    fun findByRootTaxIdentifier(rootTaxIdentifier: String): List<CardReceivablesSchedule>
}

// Implementation
@Component
class CardReceivablesScheduleDataAccessImpl(
    private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

    override fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        return repository.findByTaxIdentifier(taxIdentifier)
    }

    override fun findByRootTaxIdentifier(rootTaxIdentifier: String): List<CardReceivablesSchedule> {
        require(rootTaxIdentifier.matches(Regex("\\d{8}"))) { "Root tax identifier must be an 8-digit CNPJ root" }
        return repository.findByRootTaxIdentifier(rootTaxIdentifier)
    }
}
```

```kotlin
package com.finapp.dataaccess

import com.finapp.repository.CardReceivablesSchedule
import com.finapp.repository.CardReceivablesScheduleRepository
import org.springframework.stereotype.Component

// Data Access Interface
interface CardReceivablesScheduleDataAccess {
    fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesSchedule>
    fun findByRootTaxIdentifier(rootTaxIdentifier: String): List<CardReceivablesSchedule>
}

// Implementation
@Component
class CardReceivablesScheduleDataAccessImpl(
    private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

    override fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        return repository.findByTaxIdentifier(taxIdentifier)
    }

    override fun findByRootTaxIdentifier(rootTaxIdentifier: String): List<CardReceivablesSchedule> {
        require(rootTaxIdentifier.matches(Regex("\\d{8}"))) { "Root tax identifier must be an 8-digit CNPJ root" }
        return repository.findByRootTaxIdentifier(rootTaxIdentifier)
    }
}
```
```kotlin
package com.finapp.repository

import jakarta.persistence.*
import org.hibernate.annotations.CreationTimestamp
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import java.time.LocalDate
import java.time.LocalDateTime

// Entity
@Entity
@Table(name = "card_receivables_schedules")
data class CardReceivablesSchedule(
    @Id
    @Column(length = 26)
    val id: String,

    @Column(name = "tax_identifier", length = 26, nullable = false)
    val taxIdentifier: String,

    @Column(length = 20, nullable = false)
    val register: String,

    @Column(length = 3, nullable = false)
    val arrangement: String,

    @Column(length = 20, nullable = false)
    val accreditor: String,

    @Column(length = 20, nullable = false)
    val source: String,

    @Column(name = "start_date", nullable = false)
    val startDate: LocalDate,

    @Column(name = "end_date", nullable = false)
    val endDate: LocalDate,

    @Column(columnDefinition = "jsonb", nullable = false)
    val schedules: String,

    @CreationTimestamp
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime? = null
)

// Repository
interface CardReceivablesScheduleRepository : JpaRepository<CardReceivablesSchedule, String> {
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier")
    fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesSchedule>
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE SUBSTRING(c.taxIdentifier, 1, 8) = :rootTaxIdentifier")
    fun findByRootTaxIdentifier(rootTaxIdentifier: String): List<CardReceivablesSchedule>
    
    @Query("SELECT c FROM CardReceivablesSchedule c WHERE c.taxIdentifier = :taxIdentifier " +
           "AND c.register = :register AND c.arrangement = :arrangement " +
           "AND c.accreditor = :accreditor AND c.source = :source")
    fun findByCompositeKey(
        taxIdentifier: String,
        register: String,
        arrangement: String,
        accreditor: String,
        source: String
    ): List<CardReceivablesSchedule>
}
```

```sql
CREATE TABLE card_receivables_schedules (
    id VARCHAR(26) NOT NULL,
    tax_identifier VARCHAR(26) NOT NULL,
    register VARCHAR(20) NOT NULL,
    arrangement VARCHAR(3) NOT NULL,
    accreditor VARCHAR(20) NOT NULL,
    source VARCHAR(20) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    schedules JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL,
    PRIMARY KEY (id)
);
CREATE INDEX idx_tax_identifier ON card_receivables_schedules (tax_identifier);
CREATE INDEX idx_tax_identifier_root ON card_receivables_schedules (SUBSTRING(tax_identifier, 1, 8));

```

```sql
CREATE TABLE card_receivables_schedules (
    id VARCHAR(26) NOT NULL,
    tax_identifier VARCHAR(26) NOT NULL,
    register VARCHAR(20) NOT NULL,
    arrangement VARCHAR(3) NOT NULL,
    accreditor VARCHAR(20) NOT NULL,
    source VARCHAR(20) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    schedules JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL,
    PRIMARY KEY (id)
);
CREATE INDEX idx_tax_identifier ON card_receivables_schedules (tax_identifier);
CREATE INDEX idx_tax_identifier_root ON card_receivables_schedules (left(tax_identifier, 8));
CREATE INDEX idx_date_range ON card_receivables_schedules (start_date, end_date);
```
```kotlin
package com.finapp.dataaccess

import com.finapp.repository.CardReceivablesSchedule
import com.finapp.repository.CardReceivablesScheduleRepository
import org.springframework.stereotype.Component
import java.time.LocalDate

interface CardReceivablesScheduleDataAccess {
    fun findByTaxIdentifierAndDateOverlap(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByTaxIdentifierAndStartDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByTaxIdentifierAndEndDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule>
    fun findByCompositeKeyAndDateOverlap(
        taxIdentifier: String,
        register: String,
        arrangement: String,
        accreditor: String,
        source: String,
        startDate: LocalDate,
        endDate: LocalDate
    ): List<CardReceivablesSchedule>
}

@Component
class CardReceivablesScheduleDataAccessImpl(
    private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

    override fun findByTaxIdentifierAndDateOverlap(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)
    }

    override fun findByTaxIdentifierAndStartDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByTaxIdentifierAndStartDateBetween(taxIdentifier, startDate, endDate)
    }

    override fun findByTaxIdentifierAndEndDateBetween(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByTaxIdentifierAndEndDateBetween(taxIdentifier, startDate, endDate)
    }

    override fun findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(rootTaxIdentifier.matches(Regex("\\d{8}"))) { "Root tax identifier must be an 8-digit CNPJ root" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate)
    }

    override fun findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(rootTaxIdentifier.matches(Regex("\\d{8}"))) { "Root tax identifier must be an 8-digit CNPJ root" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier, startDate, endDate)
    }

    override fun findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        require(rootTaxIdentifier.matches(Regex("\\d{8}"))) { "Root tax identifier must be an 8-digit CNPJ root" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier, startDate, endDate)
    }

    override fun findByCompositeKeyAndDateOverlap(
        taxIdentifier: String,
        register: String,
        arrangement: String,
        accreditor: String,
        source: String,
        startDate: LocalDate,
        endDate: LocalDate
    ): List<CardReceivablesSchedule> {
        require(taxIdentifier.matches(Regex("\\d{14}"))) { "Tax identifier must be a 14-digit CNPJ" }
        require(register.length <= 20) { "Register must not exceed 20 characters" }
        require(arrangement.length <= 3) { "Arrangement must not exceed 3 characters" }
        require(accreditor.length <= 20) { "Accreditor must not exceed 20 characters" }
        require(source.length <= 20) { "Source must not exceed 20 characters" }
        require(startDate <= endDate) { "Start date must not be after end date" }
        return repository.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate)
    }
}
```
```kotlin
package com.finapp.repository

import com.finapp.dataaccess.CardReceivablesScheduleDataAccess
import org.springframework.stereotype.Service
import java.time.LocalDate
import java.util.UUID

@Service
class CardReceivablesScheduleService(
    private val dataAccess: CardReceivablesScheduleDataAccess,
    private val repository: CardReceivablesScheduleRepository
) {
    fun saveSchedule(schedule: CardReceivablesSchedule): CardReceivablesSchedule {
        val scheduleToSave = schedule.copy(
            schedules = schedule.schedules.takeIf { it.isNotEmpty() } ?: "[]"
        )
        return repository.save(scheduleToSave)
    }

    fun getSchedulesByTaxIdentifier(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        val schedules = dataAccess.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)
        if (schedules.isNotEmpty()) {
            return schedules
        }
        val emptySchedule = createEmptySchedule(taxIdentifier, startDate, endDate)
        repository.save(emptySchedule)
        return listOf(emptySchedule)
    }

    fun getSchedulesByRootTaxIdentifier(rootTaxIdentifier: String, startDate: LocalDate, endDate: LocalDate): List<CardReceivablesSchedule> {
        val schedules = dataAccess.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate)
        if (schedules.isNotEmpty()) {
            return schedules
        }
        val paddedCnpj = rootTaxIdentifier.padEnd(14, '0')
        val emptySchedule = createEmptySchedule(paddedCnpj, startDate, endDate)
        repository.save(emptySchedule)
        return listOf(emptySchedule)
    }

    fun getSchedulesByCompositeKey(
        taxIdentifier: String,
        register: String,
        arrangement: String,
        accreditor: String,
        source: String,
        startDate: LocalDate,
        endDate: LocalDate
    ): List<CardReceivablesSchedule> {
        val schedules = dataAccess.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate)
        if (schedules.isNotEmpty()) {
            return schedules
        }
        val emptySchedule = CardReceivablesSchedule(
            id = UUID.randomUUID().toString().replace("-", "").substring(0, 26),
            taxIdentifier = taxIdentifier,
            register = register,
            arrangement = arrangement,
            accreditor = accreditor,
            source = source,
            startDate = startDate,
            endDate = endDate,
            schedules = "[]"
        )
        repository.save(emptySchedule)
        return listOf(emptySchedule)
    }

    private fun createEmptySchedule(taxIdentifier: String, startDate: LocalDate, endDate: LocalDate): CardReceivablesSchedule {
        return CardReceivablesSchedule(
            id = UUID.randomUUID().toString().replace("-", "").substring(0, 26),
            taxIdentifier = taxIdentifier,
            register = "",
            arrangement = "",
            accreditor = "",
            source = "ONLINE",
            startDate = startDate,
            endDate = endDate,
            schedules = "[]"
        )
    }
}
```
```kotlin
package com.finapp.dataaccess

import com.finapp.repository.CardReceivablesSchedule
import com.finapp.repository.CardReceivablesScheduleRepository
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.whenever
import java.time.LocalDate
import java.time.LocalDateTime
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.assertThrows

@ExtendWith(MockitoExtension::class)
class CardReceivablesScheduleDataAccessTest {

    @Mock
    private lateinit var repository: CardReceivablesScheduleRepository

    @InjectMocks
    private lateinit var dataAccess: CardReceivablesScheduleDataAccessImpl

    private val testSchedules = listOf(
        CardReceivablesSchedule(
            id = "123e4567e89b12d3a456426614",
            taxIdentifier = "12345678000195",
            register = "CERC",
            arrangement = "VIS",
            accreditor = "CIELO",
            source = "ONLINE",
            startDate = LocalDate.of(2025, 7, 1),
            endDate = LocalDate.of(2025, 7, 31),
            schedules = """[{"date": "2025-07-01", "amount": 1000.50}, {"date": "2025-07-15", "amount": 2000.75}]""",
            createdAt = LocalDateTime.of(2025, 7, 15, 10, 0, 0)
        ),
        CardReceivablesSchedule(
            id = "223e4567e89b12d3a456426614",
            taxIdentifier = "12345678000296",
            register = "NUCLEA",
            arrangement = "MAS",
            accreditor = "REDECARD",
            source = "FILE",
            startDate = LocalDate.of(2025, 6, 15),
            endDate = LocalDate.of(2025, 7, 15),
            schedules = """[{"date": "2025-07-02", "amount": 1500.25}]""",
            createdAt = LocalDateTime.of(2025, 7, 15, 10, 1, 0)
        ),
        CardReceivablesSchedule(
            id = "323e4567e89b12d3a456426614",
            taxIdentifier = "98765432000188",
            register = "CERC",
            arrangement = "VIS",
            accreditor = "CIELO",
            source = "ONLINE",
            startDate = LocalDate.of(2025, 7, 1),
            endDate = LocalDate.of(2025, 7, 31),
            schedules = "[]",
            createdAt = LocalDateTime.of(2025, 7, 15, 10, 2, 0)
        ),
        CardReceivablesSchedule(
            id = "423e4567e89b12d3a456426614",
            taxIdentifier = "12345678000397",
            register = "CERC",
            arrangement = "AME",
            accreditor = "GETNET",
            source = "FILE",
            startDate = LocalDate.of(2025, 7, 10),
            endDate = LocalDate.of(2025, 8, 10),
            schedules = """[{"date": "2025-07-03", "amount": 3000.00}]""",
            createdAt = LocalDateTime.of(2025, 7, 15, 10, 3, 0)
        ),
        CardReceivablesSchedule(
            id = "523e4567e89b12d3a456426614",
            taxIdentifier = "45678912000177",
            register = "NUCLEA",
            arrangement = "MAS",
            accreditor = "STONE",
            source = "ONLINE",
            startDate = LocalDate.of(2025, 6, 1),
            endDate = LocalDate.of(2025, 6, 30),
            schedules = """[{"date": "2025-06-04", "amount": 2500.30}, {"date": "2025-06-05", "amount": 1800.60}]""",
            createdAt = LocalDateTime.of(2025, 7, 15, 10, 4, 0)
        )
    )

    @Test
    fun `findByTaxIdentifierAndDateOverlap should return schedules for existing CNPJ and overlapping date range`() {
        val taxIdentifier = "12345678000195"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier == taxIdentifier &&
                it.startDate <= endDate && it.endDate >= startDate
            })

        val schedules = dataAccess.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("123e4567e89b12d3a456426614", schedule.id)
        assertEquals(taxIdentifier, schedule.taxIdentifier)
        assertEquals("CERC", schedule.register)
        assertEquals("VIS", schedule.arrangement)
        assertEquals("CIELO", schedule.accreditor)
        assertEquals("ONLINE", schedule.source)
        assertEquals("""[{"date": "2025-07-01", "amount": 1000.50}, {"date": "2025-07-15", "amount": 2000.75}]""", schedule.schedules)
        assertEquals(LocalDate.of(2025, 7, 1), schedule.startDate)
        assertEquals(LocalDate.of(2025, 7, 31), schedule.endDate)
    }

    @Test
    fun `findByTaxIdentifierAndStartDateBetween should return schedules for existing CNPJ and start date in range`() {
        val taxIdentifier = "12345678000195"
        val startDate = LocalDate.of(2025, 6, 30)
        val endDate = LocalDate.of(2025, 7, 2)
        whenever(repository.findByTaxIdentifierAndStartDateBetween(taxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier == taxIdentifier &&
                it.startDate in startDate..endDate
            })

        val schedules = dataAccess.findByTaxIdentifierAndStartDateBetween(taxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("123e4567e89b12d3a456426614", schedule.id)
        assertEquals(taxIdentifier, schedule.taxIdentifier)
        assertEquals(LocalDate.of(2025, 7, 1), schedule.startDate)
    }

    @Test
    fun `findByTaxIdentifierAndEndDateBetween should return schedules for existing CNPJ and end date in range`() {
        val taxIdentifier = "12345678000397"
        val startDate = LocalDate.of(2025, 8, 1)
        val endDate = LocalDate.of(2025, 8, 15)
        whenever(repository.findByTaxIdentifierAndEndDateBetween(taxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier == taxIdentifier &&
                it.endDate in startDate..endDate
            })

        val schedules = dataAccess.findByTaxIdentifierAndEndDateBetween(taxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("423e4567e89b12d3a456426614", schedule.id)
        assertEquals(taxIdentifier, schedule.taxIdentifier)
        assertEquals(LocalDate.of(2025, 8, 10), schedule.endDate)
    }

    @Test
    fun `findByTaxIdentifierAndDateOverlap should return empty list for non-existent CNPJ`() {
        val taxIdentifier = "99999999000199"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate))
            .thenReturn(emptyList())

        val schedules = dataAccess.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)

        assertTrue(schedules.isEmpty())
    }

    @Test
    fun `findByTaxIdentifierAndDateOverlap should throw IllegalArgumentException for invalid CNPJ`() {
        val invalidTaxIdentifier = "123456789"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        val exception = assertThrows<IllegalArgumentException> {
            dataAccess.findByTaxIdentifierAndDateOverlap(invalidTaxIdentifier, startDate, endDate)
        }
        assertEquals("Tax identifier must be a 14-digit CNPJ", exception.message)
    }

    @Test
    fun `findByTaxIdentifierAndDateOverlap should throw IllegalArgumentException for invalid date range`() {
        val taxIdentifier = "12345678000195"
        val startDate = LocalDate.of(2025, 7, 31)
        val endDate = LocalDate.of(2025, 7, 1)
        val exception = assertThrows<IllegalArgumentException> {
            dataAccess.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)
        }
        assertEquals("Start date must not be after end date", exception.message)
    }

    @Test
    fun `findByTaxIdentifierAndDateOverlap should return empty schedules for negative cache case`() {
        val taxIdentifier = "98765432000188"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier == taxIdentifier &&
                it.startDate <= endDate && it.endDate >= startDate
            })

        val schedules = dataAccess.findByTaxIdentifierAndDateOverlap(taxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("323e4567e89b12d3a456426614", schedule.id)
        assertEquals(taxIdentifier, schedule.taxIdentifier)
        assertEquals("[]", schedule.schedules)
        assertEquals(LocalDate.of(2025, 7, 1), schedule.startDate)
        assertEquals(LocalDate.of(2025, 7, 31), schedule.endDate)
    }

    @Test
    fun `findByRootTaxIdentifierAndDateOverlap should return schedules for existing root CNPJ and overlapping date range`() {
        val rootTaxIdentifier = "12345678"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier.startsWith(rootTaxIdentifier) &&
                it.startDate <= endDate && it.endDate >= startDate
            })

        val schedules = dataAccess.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate)

        assertEquals(3, schedules.size)
        val taxIdentifiers = schedules.map { it.taxIdentifier }.toSet()
        assertEquals(setOf("12345678000195", "12345678000296", "12345678000397"), taxIdentifiers)
        schedules.forEach { schedule ->
            assertTrue(schedule.startDate <= endDate && schedule.endDate >= startDate)
        }
    }

    @Test
    fun `findByRootTaxIdentifierAndStartDateBetween should return schedules for existing root CNPJ and start date in range`() {
        val rootTaxIdentifier = "12345678"
        val startDate = LocalDate.of(2025, 6, 30)
        val endDate = LocalDate.of(2025, 7, 2)
        whenever(repository.findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier.startsWith(rootTaxIdentifier) &&
                it.startDate in startDate..endDate
            })

        val schedules = dataAccess.findByRootTaxIdentifierAndStartDateBetween(rootTaxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("123e4567e89b12d3a456426614", schedule.id)
        assertEquals("12345678000195", schedule.taxIdentifier)
        assertEquals(LocalDate.of(2025, 7, 1), schedule.startDate)
    }

    @Test
    fun `findByRootTaxIdentifierAndEndDateBetween should return schedules for existing root CNPJ and end date in range`() {
        val rootTaxIdentifier = "12345678"
        val startDate = LocalDate.of(2025, 8, 1)
        val endDate = LocalDate.of(2025, 8, 15)
        whenever(repository.findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier.startsWith(rootTaxIdentifier) &&
                it.endDate in startDate..endDate
            })

        val schedules = dataAccess.findByRootTaxIdentifierAndEndDateBetween(rootTaxIdentifier, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("423e4567e89b12d3a456426614", schedule.id)
        assertEquals("12345678000397", schedule.taxIdentifier)
        assertEquals(LocalDate.of(2025, 8, 10), schedule.endDate)
    }

    @Test
    fun `findByRootTaxIdentifierAndDateOverlap should return empty list for non-existent root CNPJ`() {
        val rootTaxIdentifier = "88888888"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate))
            .thenReturn(emptyList())

        val schedules = dataAccess.findByRootTaxIdentifierAndDateOverlap(rootTaxIdentifier, startDate, endDate)

        assertTrue(schedules.isEmpty())
    }

    @Test
    fun `findByRootTaxIdentifierAndDateOverlap should throw IllegalArgumentException for invalid root CNPJ`() {
        val invalidRootTaxIdentifier = "1234567"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        val exception = assertThrows<IllegalArgumentException> {
            dataAccess.findByRootTaxIdentifierAndDateOverlap(invalidRootTaxIdentifier, startDate, endDate)
        }
        assertEquals("Root tax identifier must be an 8-digit CNPJ root", exception.message)
    }

    @Test
    fun `findByCompositeKeyAndDateOverlap should return schedule for existing composite key and overlapping date range`() {
        val taxIdentifier = "12345678000296"
        val register = "NUCLEA"
        val arrangement = "MAS"
        val accreditor = "REDECARD"
        val source = "FILE"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate))
            .thenReturn(testSchedules.filter {
                it.taxIdentifier == taxIdentifier &&
                it.register == register &&
                it.arrangement == arrangement &&
                it.accreditor == accreditor &&
                it.source == source &&
                it.startDate <= endDate && it.endDate >= startDate
            })

        val schedules = dataAccess.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate)

        assertEquals(1, schedules.size)
        val schedule = schedules[0]
        assertEquals("223e4567e89b12d3a456426614", schedule.id)
        assertEquals(taxIdentifier, schedule.taxIdentifier)
        assertEquals(register, schedule.register)
        assertEquals(arrangement, schedule.arrangement)
        assertEquals(accreditor, schedule.accreditor)
        assertEquals(source, schedule.source)
        assertEquals("""[{"date": "2025-07-02", "amount": 1500.25}]""", schedule.schedules)
        assertEquals(LocalDate.of(2025, 6, 15), schedule.startDate)
        assertEquals(LocalDate.of(2025, 7, 15), schedule.endDate)
    }

    @Test
    fun `findByCompositeKeyAndDateOverlap should return empty list for non-existent composite key`() {
        val taxIdentifier = "99999999000199"
        val register = "CERC"
        val arrangement = "VIS"
        val accreditor = "CIELO"
        val source = "ONLINE"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)
        whenever(repository.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate))
            .thenReturn(emptyList())

        val schedules = dataAccess.findByCompositeKeyAndDateOverlap(taxIdentifier, register, arrangement, accreditor, source, startDate, endDate)

        assertTrue(schedules.isEmpty())
    }

    @Test
    fun `findByCompositeKeyAndDateOverlap should throw IllegalArgumentException for invalid inputs`() {
        val validTaxIdentifier = "12345678000195"
        val invalidRegister = "CERC".padEnd(21, 'X')
        val validArrangement = "VIS"
        val validAccreditor = "CIELO"
        val validSource = "ONLINE"
        val startDate = LocalDate.of(2025, 7, 1)
        val endDate = LocalDate.of(2025, 7, 31)

        val exception = assertThrows<IllegalArgumentException> {
            dataAccess.findByCompositeKeyAndDateOverlap(validTaxIdentifier, invalidRegister, validArrangement, validAccreditor, validSource, startDate, endDate)
        }
        assertEquals("Register must not exceed 20 characters", exception.message)
    }
}
```










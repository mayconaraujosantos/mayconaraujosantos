# Maycon Araujo - Senior Software Engineer

## üíº Perfil Profissional

Engenheiro de Software S√™nior com vasta experi√™ncia na concep√ß√£o, desenvolvimento e implementa√ß√£o de solu√ß√µes de backend robustas e escal√°veis, especialmente em arquiteturas de microsservi√ßos. Possuo um profundo conhecimento do ecossistema Java e suas tecnologias de ponta, com foco em construir sistemas resilientes, perform√°ticos e seguros. Minha trajet√≥ria profissional √© marcada pela lideran√ßa t√©cnica, mentoria de equipes e um compromisso constante com a qualidade do c√≥digo e as melhores pr√°ticas de desenvolvimento.

## üõ†Ô∏è Expertise T√©cnica Principal

* **Linguagens:**
    * ![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white) 11, 17, profici√™ncia em programa√ß√£o concorrente e reativa.
* **Frameworks/Bibliotecas Backend:**
    * **Spring Ecosystem:**
        * ![Spring Boot](https://img.shields.io/badge/Spring_Boot-F2F4F9?style=for-the-badge&logo=spring-boot) Spring Boot (experi√™ncia avan√ßada em configura√ß√£o e otimiza√ß√£o),
        * ![Spring Cloud](https://img.shields.io/badge/Spring_Cloud-F2F4F9?style=for-the-badge&logo=spring-cloud) Spring Cloud (Service Discovery, Configuration Management, Gateway, Circuit Breakers, Stream),
        * ![Spring Security](https://img.shields.io/badge/Spring_Security-F2F4F9?style=for-the-badge&logo=spring-security) Spring Security (implementa√ß√£o de seguran√ßa com OAuth 2.0, JWT),
        * ![Spring Data JPA](https://img.shields.io/badge/Spring_Data_JPA-F2F4F9?style=for-the-badge&logo=spring-data-jpa) Spring Data JPA (otimiza√ß√£o de queries e estrat√©gias de persist√™ncia),
        * ![Lombok](https://img.shields.io/badge/Lombok-F2F4F9?style=for-the-badge&logo=projectlombok) Lombok.
    * **Persist√™ncia:**
        * ![JPA](https://img.shields.io/badge/JPA-F2F4F9?style=for-the-badge) JPA,
        * ![Flyway](https://img.shields.io/badge/Flyway-F2F4F9?style=for-the-badge&logo=flyway) Flyway (gerenciamento de migra√ß√µes de banco de dados).
    * **Mensageria:**
        * ![Apache Kafka](https://img.shields.io/badge/Apache_Kafka-000?style=for-the-badge&logo=apache-kafka) Kafka (arquitetura, streams, conectores),
        * ![RabbitMQ](https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white) RabbitMQ (roteamento avan√ßado, confiabilidade),
        * ![Google Cloud Pub/Sub](https://img.shields.io/badge/Google_Cloud_Pub/Sub-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%231E8E3E) Pub/Sub (GCP).
    * **Cache:**
        * ![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white) Redis (estrat√©gias de cache distribu√≠do).
    * **Comunica√ß√£o:**
        * ![gRPC](https://img.shields.io/badge/gRPC-F2F4F9?style=for-the-badge&logo=grpc) gRPC.
* **Testes:**
    * ![TDD](https://img.shields.io/badge/TDD-F2F4F9?style=for-the-badge) TDD (Desenvolvimento Guiado por Testes),
    * ![JUnit](https://img.shields.io/badge/JUnit-25A18E?style=for-the-badge&logo=junit5&logoColor=white) JUnit 4/5 (cria√ß√£o de testes unit√°rios abrangentes),
    * ![BDD](https://img.shields.io/badge/BDD-F2F4F9?style=for-the-badge) BDD (Desenvolvimento Orientado a Comportamento) com
    * ![Cucumber](https://img.shields.io/badge/Cucumber-232323?style=for-the-badge&logo=cucumber&logoColor=white) Cucumber (defini√ß√£o de cen√°rios em linguagem natural).
* **Cloud Computing:**
    * ![Amazon AWS](https://img.shields.io/badge/Amazon_AWS-232F3E?style=for-the-badge&logo=amazon-aws&logoColor=white) AWS (
        * ![Amazon SQS](https://img.shields.io/badge/Amazon_SQS-FF4F00?style=for-the-badge&logo=amazon-sqs&logoColor=white) SQS,
        * ![Amazon RDS](https://img.shields.io/badge/Amazon_RDS-0077B6?style=for-the-badge&logo=amazon-rds&logoColor=white) RDS,
        * ![Amazon SNS](https://img.shields.io/badge/Amazon_SNS-FF9900?style=for-the-badge&logo=amazon-sns&logoColor=white) SNS,
        * ![Amazon S3](https://img.shields.io/badge/Amazon_S3-569A31?style=for-the-badge&logo=amazon-s3&logoColor=white) S3,
        * ![Amazon ECR](https://img.shields.io/badge/Amazon_ECR-00AEEF?style=for-the-badge&logo=amazon-ecr&logoColor=white) ECR,
        * ![Amazon EKS](https://img.shields.io/badge/Amazon_EKS-000?style=for-the-badge&logo=amazon-eks&logoColor=white) EKS
    ),
    * ![Google Cloud](https://img.shields.io/badge/Google_Cloud-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white) GCP (
        * ![Google Cloud Functions](https://img.shields.io/badge/Google_Cloud_Functions-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%23E91E63) Cloud Functions,
        * ![Google BigQuery](https://img.shields.io/badge/Google_BigQuery-F2F4F9?style=for-the-badge&logo=google-bigquery&logoColor=%234285F4) BigQuery
    ).
* **Containeriza√ß√£o e Orquestra√ß√£o:**
    * ![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white) Docker,
    * ![Kubernetes](https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=kubernetes&logoColor=white) Kubernetes.
* **Monitoramento e Observabilidade:**
    * ![Grafana](https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white) Grafana,
    * ![New Relic](https://img.shields.io/badge/New_Relic-00A63F?style=for-the-badge&logo=new-relic&logoColor=white) Relic,
    * ![Splunk](https://img.shields.io/badge/Splunk-000000?style=for-the-badge&logo=splunk&logoColor=white) Splunk.
* **CI/CD:**
    * ![Jenkins](https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white) Jenkins,
    * ![GitHub Actions](https://img.shields.io/badge/GitHub_Actions-2088FF?style=for-the-badge&logo=github-actions&logoColor=white) GitHub Actions,
    * ![GitLab CI](https://img.shields.io/badge/GitLab_CI-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab CI.
* **Frontend (Conhecimento):**
    * ![Angular](https://img.shields.io/badge/Angular-DD0031?style=for-the-badge&logo=angular&logoColor=white) Angular,
    * ![TypeScript](https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white) TypeScript.
* **Gerenciamento de C√≥digo:**
    * ![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white) Git,
    * ![GitLab](https://img.shields.io/badge/GitLab-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab,
    * ![GitFlow](https://img.shields.io/badge/GitFlow-F2F4F9?style=for-the-badge) GitFlow.
* **Gerenciamento de Projetos:**
    * ![Jira](https://img.shields.io/badge/Jira-0052CC?style=for-the-badge&logo=jira&logoColor=white) Jira,
    * ![Scrum](https://img.shields.io/badge/Scrum-F2F4F9?style=for-the-badge) Scrum.

## üí° Experi√™ncia Profissional

Minha experi√™ncia abrange a lideran√ßa t√©cnica e a contribui√ß√£o individual em projetos complexos, incluindo:

* **Desenvolvimento e evolu√ß√£o de plataformas de microsservi√ßos** utilizando Spring Boot e Spring Cloud, garantindo alta escalabilidade e resili√™ncia.
* **Implementa√ß√£o de solu√ß√µes de mensageria robustas** com Kafka e RabbitMQ para comunica√ß√£o ass√≠ncrona e processamento de eventos em larga escala.
* **Desenvolvimento de APIs RESTful seguras e perform√°ticas** com Spring Security, seguindo as melhores pr√°ticas de design e documenta√ß√£o.
* **Utiliza√ß√£o extensiva de bancos de dados relacionais (JPA, Flyway) e NoSQL (Redis)**, com foco em otimiza√ß√£o de performance e modelagem de dados eficiente.
* **Implementa√ß√£o de testes automatizados em todas as camadas (unit√°rios, integra√ß√£o, BDD)** para garantir a qualidade e a estabilidade do software.
* **Experi√™ncia pr√°tica com plataformas de cloud (AWS e GCP)**, incluindo a utiliza√ß√£o de servi√ßos como SQS, RDS, SNS, S3, ECR, EKS, Cloud Functions e BigQuery.
* **Cria√ß√£o e gerenciamento de pipelines de CI/CD** com Jenkins e GitHub Actions para automatizar o processo de entrega de software.
* **Monitoramento e an√°lise de sistemas em produ√ß√£o** utilizando Grafana, Relic e Splunk para identificar e solucionar problemas proativamente.
* **Colabora√ß√£o em equipes multidisciplinares utilizando a metodologia Scrum e ferramentas como Jira.**
* **Mentoria de desenvolvedores juniores e plenos, compartilhando conhecimento e promovendo o crescimento t√©cnico.**

*(Aqui voc√™ pode adicionar detalhes mais espec√≠ficos sobre seus projetos e responsabilidades em cada experi√™ncia profissional, se desejar.)*

## üî≠ Projetos Pessoais e Contribui√ß√µes

* **[Nome do Projeto Pessoal 1](Link do Projeto 1):** Breve descri√ß√£o do projeto, destacando as tecnologias avan√ßadas utilizadas (ex: arquitetura reativa com Spring WebFlux e Kafka Streams).
* **[Nome do Projeto Pessoal 2](Link do Projeto 2):** Contribui√ß√£o significativa para algum projeto Open Source relevante em alguma das tecnologias listadas.
* **[Nome do Projeto Pessoal 3](Link do Projeto 3):** Demonstra√ß√£o de habilidades espec√≠ficas em alguma tecnologia (ex: implementa√ß√£o de um sistema de filas distribu√≠das com RabbitMQ com padr√µes de confiabilidade).

*(Inclua links para seus projetos mais relevantes no GitHub ou outras plataformas.)*

## ü§ù Conecte-se

* [LinkedIn](https://www.linkedin.com/in/maycon-araujo/)
* [GitHub](Seu Link do GitHub)
* [Seu Email Profissional]

## ‚ö° Interesses

* Explora√ß√£o de novas tecnologias e tend√™ncias no desenvolvimento de software.
* Participa√ß√£o em comunidades t√©cnicas e compartilhamento de conhecimento.
* Busca cont√≠nua por aprimoramento em arquiteturas de sistemas distribu√≠dos e escal√°veis.

Agrade√ßo o seu interesse em meu perfil. Estou sempre aberto a novas oportunidades e desafios que me permitam aplicar e expandir minhas habilidades. 

```kotlin
package com.c6bak.finappguaranteecardreceivables.dataaccess

import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import com.c6bak.finappguaranteecardreceivables.resources.repositories.CardReceivablesScheduleRepository
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import java.time.LocalDate
import org.springframework.stereotype.Component

private val objectMapper = jacksonObjectMapper()

@Component
class CardReceivablesScheduleDataAccessImpl(
        private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

  override fun existsByTaxIdentifier(taxIdentifier: String): Boolean {
    return repository.findByTaxIdentifier(taxIdentifier).isNotEmpty()
  }

  override fun existsByRootTaxIdentifier(rootTaxIdentifier: String): Boolean {
    return findSchedulesByRootTaxIdentifier(rootTaxIdentifier, LocalDate.MIN, LocalDate.MAX)
            .isNotEmpty()
  }

  override fun findSchedulesByTaxIdentifier(
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasTaxIdentifier(taxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun findSchedulesByRootTaxIdentifier(
          rootTaxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasRootTaxIdentifier(rootTaxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun saveSchedules(schedules: List<CardReceivablesSchedule>) {
    val entities = schedules.map { it.toTableEntity() }
    repository.saveAll(entities)
  }
}

// Extensions para convers√£o entre entidades
private fun CardReceivablesScheduleTable.toDomainEntity(): CardReceivablesSchedule {
  return CardReceivablesSchedule(
          id = this.id,
          taxIdentifier = this.taxIdentifier,
          register =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Register.valueOf(
                          this.register
                  ),
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Source.valueOf(
                          this.source
                  ),
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.readValue(this.schedules),
          createdAt = this.createdAt
  )
}

private fun CardReceivablesSchedule.toTableEntity(): CardReceivablesScheduleTable {
  return CardReceivablesScheduleTable(
          id = this.id,
          register = this.register.value,
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source = this.source.value,
          taxIdentifier = this.taxIdentifier,
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.writeValueAsString(this.schedules),
          createdAt = this.createdAt
  )
}



package com.c6bak.finappguaranteecardreceivables.dataaccess

import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import com.c6bak.finappguaranteecardreceivables.resources.repositories.CardReceivablesScheduleRepository
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import java.time.LocalDate
import org.springframework.stereotype.Component

private val objectMapper = jacksonObjectMapper()

@Component
class CardReceivablesScheduleDataAccessImpl(
        private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

  override fun existsByTaxIdentifier(taxIdentifier: String): Boolean {
    return repository.findByTaxIdentifier(taxIdentifier).isNotEmpty()
  }

  override fun existsByRootTaxIdentifier(rootTaxIdentifier: String): Boolean {
    return findSchedulesByRootTaxIdentifier(rootTaxIdentifier, LocalDate.MIN, LocalDate.MAX)
            .isNotEmpty()
  }

  override fun findSchedulesByTaxIdentifier(
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasTaxIdentifier(taxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun findSchedulesByRootTaxIdentifier(
          rootTaxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasRootTaxIdentifier(rootTaxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun saveSchedules(schedules: List<CardReceivablesSchedule>) {
    val entities = schedules.map { it.toTableEntity() }
    repository.saveAll(entities)
  }
}

// Extensions para convers√£o entre entidades
private fun CardReceivablesScheduleTable.toDomainEntity(): CardReceivablesSchedule {
  return CardReceivablesSchedule(
          id = this.id,
          taxIdentifier = this.taxIdentifier,
          register =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Register.valueOf(
                          this.register
                  ),
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Source.valueOf(
                          this.source
                  ),
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.readValue(this.schedules),
          createdAt = this.createdAt
  )
}

private fun CardReceivablesSchedule.toTableEntity(): CardReceivablesScheduleTable {
  return CardReceivablesScheduleTable(
          id = this.id,
          register = this.register.value,
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source = this.source.value,
          taxIdentifier = this.taxIdentifier,
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.writeValueAsString(this.schedules),
          createdAt = this.createdAt
  )
}

package com.c6bak.finappguaranteecardreceivables.resources.repositories

import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import java.time.LocalDate
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.JpaSpecificationExecutor
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface CardReceivablesScheduleRepository :
        JpaRepository<CardReceivablesScheduleTable, String>,
        JpaSpecificationExecutor<CardReceivablesScheduleTable> {

  // Save schedules (herdado do JpaRepository - save() method)

  // Get schedules pelo CNPJ inteiro
  fun findByTaxIdentifier(taxIdentifier: String): List<CardReceivablesScheduleTable>

  // Get schedules pelo CNPJ inteiro + intervalo de datas
  fun findByTaxIdentifierAndStartDateGreaterThanEqualAndEndDateLessThanEqual(
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesScheduleTable>

  // Get schedules pelo CNPJ raiz (primeiros 9 d√≠gitos) usando LIKE
  @Query(
          """
      SELECT c FROM CardReceivablesScheduleTable c
      WHERE c.taxIdentifier LIKE CONCAT(:rootTaxIdentifier, '%')
    """
  )
  fun findByRootTaxIdentifier(
          @Param("rootTaxIdentifier") rootTaxIdentifier: String
  ): List<CardReceivablesScheduleTable>

  // Get schedules pelo CNPJ raiz + intervalo de datas usando LIKE
  @Query(
          """
      SELECT c FROM CardReceivablesScheduleTable c
      WHERE c.taxIdentifier LIKE CONCAT(:rootTaxIdentifier, '%')
      AND c.startDate >= :startDate
      AND c.endDate <= :endDate
    """
  )
  fun findByRootTaxIdentifierAndStartDateGreaterThanEqualAndEndDateLessThanEqual(
          @Param("rootTaxIdentifier") rootTaxIdentifier: String,
          @Param("startDate") startDate: LocalDate,
          @Param("endDate") endDate: LocalDate
  ): List<CardReceivablesScheduleTable>
}
package com.c6bak.finappguaranteecardreceivables.domain.entities

import java.math.BigDecimal
import java.time.LocalDate
import java.time.LocalDateTime

enum class Register(val value: String) {
  CERC("CERC"),
  NUCLEA("NUCLEA")
}

enum class Source(val value: String) {
  ONLINE("ONLINE"),
  FILE("FILE")
}

data class CardReceivableScheduleItem(
        val date: LocalDate,
        val amount: BigDecimal,
        val status: String // ajuste conforme necess√°rio
)

data class CardReceivablesSchedule(
        val id: String,
        val taxIdentifier: String,
        val register: Register,
        val arrangement: String,
        val accreditor: String,
        val source: Source,
        val startDate: LocalDate,
        val endDate: LocalDate,
        val schedules: List<CardReceivableScheduleItem>,
        val createdAt: LocalDateTime
)
package com.c6bak.finappguaranteecardreceivables.dataaccess

import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import java.time.LocalDate

interface CardReceivablesScheduleDataAccess {
  fun existsByTaxIdentifier(taxIdentifier: String): Boolean
  fun existsByRootTaxIdentifier(rootTaxIdentifier: String): Boolean
  fun findSchedulesByTaxIdentifier(
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule>
  fun findSchedulesByRootTaxIdentifier(
          rootTaxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule>
  fun saveSchedules(schedules: List<CardReceivablesSchedule>)
}
package com.c6bak.finappguaranteecardreceivables.dataaccess

import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import com.c6bak.finappguaranteecardreceivables.resources.repositories.CardReceivablesScheduleRepository
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import java.time.LocalDate
import org.springframework.stereotype.Component

private val objectMapper = jacksonObjectMapper()

@Component
class CardReceivablesScheduleDataAccessImpl(
        private val repository: CardReceivablesScheduleRepository
) : CardReceivablesScheduleDataAccess {

  override fun existsByTaxIdentifier(taxIdentifier: String): Boolean {
    return repository.findByTaxIdentifier(taxIdentifier).isNotEmpty()
  }

  override fun existsByRootTaxIdentifier(rootTaxIdentifier: String): Boolean {
    return findSchedulesByRootTaxIdentifier(rootTaxIdentifier, LocalDate.MIN, LocalDate.MAX)
            .isNotEmpty()
  }

  override fun findSchedulesByTaxIdentifier(
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasTaxIdentifier(taxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun findSchedulesByRootTaxIdentifier(
          rootTaxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate
  ): List<CardReceivablesSchedule> {
    val spec =
            CardReceivablesScheduleSpecs.hasRootTaxIdentifier(rootTaxIdentifier)
                    .and(CardReceivablesScheduleSpecs.startDateAfterOrEqual(startDate))
                    .and(CardReceivablesScheduleSpecs.endDateBeforeOrEqual(endDate))
    return repository.findAll(spec).map { it.toDomainEntity() }
  }

  override fun saveSchedules(schedules: List<CardReceivablesSchedule>) {
    val entities = schedules.map { it.toTableEntity() }
    repository.saveAll(entities)
  }
}

// Extensions para convers√£o entre entidades
private fun CardReceivablesScheduleTable.toDomainEntity(): CardReceivablesSchedule {
  return CardReceivablesSchedule(
          id = this.id,
          taxIdentifier = this.taxIdentifier,
          register =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Register.valueOf(
                          this.register
                  ),
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source =
                  com.c6bak.finappguaranteecardreceivables.domain.entities.Source.valueOf(
                          this.source
                  ),
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.readValue(this.schedules),
          createdAt = this.createdAt
  )
}

private fun CardReceivablesSchedule.toTableEntity(): CardReceivablesScheduleTable {
  return CardReceivablesScheduleTable(
          id = this.id,
          register = this.register.value,
          arrangement = this.arrangement,
          accreditor = this.accreditor,
          source = this.source.value,
          taxIdentifier = this.taxIdentifier,
          startDate = this.startDate,
          endDate = this.endDate,
          schedules = objectMapper.writeValueAsString(this.schedules),
          createdAt = this.createdAt
  )
}
package com.c6bak.finappguaranteecardreceivables.resources.repositories

import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.test.assertEquals
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
import org.springframework.test.context.ActiveProfiles

@DataJpaTest
@ActiveProfiles("test")
class CardReceivablesScheduleRepositoryTest
@Autowired
constructor(val repository: CardReceivablesScheduleRepository) {
  private fun createSchedule(
          id: String,
          register: String,
          arrangement: String,
          accreditor: String,
          source: String,
          taxIdentifier: String,
          startDate: LocalDate,
          endDate: LocalDate,
          schedules: String = "[]",
          createdAt: LocalDateTime = LocalDateTime.now()
  ) =
          CardReceivablesScheduleTable(
                  id = id,
                  register = register,
                  arrangement = arrangement,
                  accreditor = accreditor,
                  source = source,
                  taxIdentifier = taxIdentifier,
                  startDate = startDate,
                  endDate = endDate,
                  schedules = schedules,
                  createdAt = createdAt
          )

  @Test
  fun `should find by taxIdentifier with and without date filter`() {
    val schedule1 =
            createSchedule(
                    "1",
                    "REG1",
                    "ARR1",
                    "ACC1",
                    "SRC1",
                    "12345678901",
                    LocalDate.of(2024, 1, 1),
                    LocalDate.of(2024, 1, 31)
            )
    val schedule2 =
            createSchedule(
                    "2",
                    "REG1",
                    "ARR1",
                    "ACC1",
                    "SRC1",
                    "12345678901",
                    LocalDate.of(2024, 2, 1),
                    LocalDate.of(2024, 2, 28)
            )
    repository.saveAll(listOf(schedule1, schedule2))

    val all = repository.findByTaxIdentifier("12345678901")
    assertEquals(2, all.size)

    val filtered =
            repository.findByTaxIdentifierAndStartDateGreaterThanEqualAndEndDateLessThanEqual(
                    "12345678901",
                    LocalDate.of(2024, 2, 1),
                    LocalDate.of(2024, 2, 28)
            )
    assertEquals(1, filtered.size)
    assertEquals("2", filtered[0].id)
  }

  @Test
  fun `should find by rootTaxIdentifier with and without date filter`() {
    val schedule1 =
            createSchedule(
                    "3",
                    "REG2",
                    "ARR2",
                    "ACC2",
                    "SRC2",
                    "98765432100",
                    LocalDate.of(2024, 3, 1),
                    LocalDate.of(2024, 3, 31)
            )
    val schedule2 =
            createSchedule(
                    "4",
                    "REG2",
                    "ARR2",
                    "ACC2",
                    "SRC2",
                    "98765432199",
                    LocalDate.of(2024, 4, 1),
                    LocalDate.of(2024, 4, 30)
            )
    repository.saveAll(listOf(schedule1, schedule2))

    val all = repository.findByRootTaxIdentifier("987654321")
    assertEquals(2, all.size)

    val filtered =
            repository.findByRootTaxIdentifierAndStartDateGreaterThanEqualAndEndDateLessThanEqual(
                    "987654321",
                    LocalDate.of(2024, 4, 1),
                    LocalDate.of(2024, 4, 30)
            )
    assertEquals(1, filtered.size)
    assertEquals("4", filtered[0].id)
  }
}
package com.c6bak.finappguaranteecardreceivables.domain.dataaccess

import com.c6bak.finappguaranteecardreceivables.dataaccess.CardReceivablesScheduleDataAccessImpl
import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import com.c6bak.finappguaranteecardreceivables.domain.entities.Register
import com.c6bak.finappguaranteecardreceivables.domain.entities.Source
import com.c6bak.finappguaranteecardreceivables.resources.repositories.CardReceivablesScheduleRepository
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.data.jpa.domain.Specification

class CardReceivablesScheduleDataAccessImplTest {
  private lateinit var repository: CardReceivablesScheduleRepository
  private lateinit var dataAccess: CardReceivablesScheduleDataAccessImpl

  @BeforeEach
  fun setUp() {
    repository = mockk(relaxed = true)
    dataAccess = CardReceivablesScheduleDataAccessImpl(repository)
  }

  private fun createTableEntity(
          id: String,
          taxIdentifier: String,
          register: Register = Register.CERC,
          arrangement: String = "ARR",
          accreditor: String = "ACC",
          source: Source = Source.ONLINE,
          startDate: LocalDate = LocalDate.of(2024, 1, 1),
          endDate: LocalDate = LocalDate.of(2024, 1, 31),
          schedules: String = "[]",
          createdAt: LocalDateTime = LocalDateTime.now()
  ) =
          CardReceivablesScheduleTable(
                  id = id,
                  register = register.value,
                  arrangement = arrangement,
                  accreditor = accreditor,
                  source = source.value,
                  taxIdentifier = taxIdentifier,
                  startDate = startDate,
                  endDate = endDate,
                  schedules = schedules,
                  createdAt = createdAt
          )

  @Test
  fun `should find schedules by taxIdentifier with date filter`() {
    // Given
    val taxIdentifier = "12345678901234"
    val startDate = LocalDate.of(2024, 2, 1)
    val endDate = LocalDate.of(2024, 2, 28)

    val tableEntities =
            listOf(
                    createTableEntity(
                            "1",
                            taxIdentifier,
                            startDate = LocalDate.of(2024, 1, 1),
                            endDate = LocalDate.of(2024, 1, 31)
                    ),
                    createTableEntity(
                            "2",
                            taxIdentifier,
                            startDate = LocalDate.of(2024, 2, 1),
                            endDate = LocalDate.of(2024, 2, 28)
                    ),
                    createTableEntity(
                            "3",
                            taxIdentifier,
                            startDate = LocalDate.of(2024, 3, 1),
                            endDate = LocalDate.of(2024, 3, 31)
                    )
            )

    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            tableEntities

    // When
    val result = dataAccess.findSchedulesByTaxIdentifier(taxIdentifier, startDate, endDate)

    // Then
    assertEquals(3, result.size)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should find schedules by rootTaxIdentifier with date filter`() {
    // Given
    val rootTaxIdentifier = "123456789"
    val startDate = LocalDate.of(2024, 4, 1)
    val endDate = LocalDate.of(2024, 4, 30)

    val tableEntities =
            listOf(
                    createTableEntity(
                            "4",
                            "12345678901234",
                            startDate = LocalDate.of(2024, 4, 1),
                            endDate = LocalDate.of(2024, 4, 15)
                    ),
                    createTableEntity(
                            "5",
                            "12345678998765",
                            startDate = LocalDate.of(2024, 4, 10),
                            endDate = LocalDate.of(2024, 4, 30)
                    ),
                    createTableEntity(
                            "6",
                            "98765432101234",
                            startDate = LocalDate.of(2024, 4, 1),
                            endDate = LocalDate.of(2024, 4, 30)
                    ) // N√£o deve ser retornado
            )

    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            tableEntities.filter { it.taxIdentifier.startsWith(rootTaxIdentifier) }

    // When
    val result = dataAccess.findSchedulesByRootTaxIdentifier(rootTaxIdentifier, startDate, endDate)

    // Then
    assertEquals(2, result.size)
    assertTrue(result.all { it.taxIdentifier.startsWith(rootTaxIdentifier) })
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should return true when taxIdentifier exists`() {
    // Given
    val taxIdentifier = "12345678901234"
    every { repository.findByTaxIdentifier(taxIdentifier) } returns
            listOf(createTableEntity("1", taxIdentifier))

    // When
    val result = dataAccess.existsByTaxIdentifier(taxIdentifier)

    // Then
    assertTrue(result)
    verify(exactly = 1) { repository.findByTaxIdentifier(taxIdentifier) }
  }

  @Test
  fun `should return false when taxIdentifier does not exist`() {
    // Given
    val taxIdentifier = "12345678901234"
    every { repository.findByTaxIdentifier(taxIdentifier) } returns emptyList()

    // When
    val result = dataAccess.existsByTaxIdentifier(taxIdentifier)

    // Then
    assertFalse(result)
    verify(exactly = 1) { repository.findByTaxIdentifier(taxIdentifier) }
  }

  @Test
  fun `should return true when rootTaxIdentifier exists`() {
    // Given
    val rootTaxIdentifier = "123456789"
    val tableEntities =
            listOf(
                    createTableEntity("1", "12345678901234"),
                    createTableEntity("2", "12345678998765")
            )
    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            tableEntities

    // When
    val result = dataAccess.existsByRootTaxIdentifier(rootTaxIdentifier)

    // Then
    assertTrue(result)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should return false when rootTaxIdentifier does not exist`() {
    // Given
    val rootTaxIdentifier = "123456789"
    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            emptyList()

    // When
    val result = dataAccess.existsByRootTaxIdentifier(rootTaxIdentifier)

    // Then
    assertFalse(result)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should save schedules correctly`() {
    // Given
    val schedules =
            listOf(
                    CardReceivablesSchedule(
                            id = "10",
                            taxIdentifier = "99999999999999",
                            register = Register.CERC,
                            arrangement = "ARR",
                            accreditor = "ACC",
                            source = Source.ONLINE,
                            startDate = LocalDate.of(2024, 1, 1),
                            endDate = LocalDate.of(2024, 1, 31),
                            schedules = emptyList(),
                            createdAt = LocalDateTime.now()
                    )
            )
    every { repository.saveAll(any<List<CardReceivablesScheduleTable>>()) } returns listOf()

    // When
    dataAccess.saveSchedules(schedules)

    // Then
    verify(exactly = 1) { repository.saveAll(any<List<CardReceivablesScheduleTable>>()) }
  }
}

```






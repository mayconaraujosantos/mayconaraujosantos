 # Maycon Araujo - Senior Software Engineer

## üíº Perfil Profissional

Engenheiro de Software S√™nior com vasta experi√™ncia na concep√ß√£o, desenvolvimento e implementa√ß√£o de solu√ß√µes de backend robustas e escal√°veis, especialmente em arquiteturas de microsservi√ßos. Possuo um profundo conhecimento do ecossistema Java e suas tecnologias de ponta, com foco em construir sistemas resilientes, perform√°ticos e seguros. Minha trajet√≥ria profissional √© marcada pela lideran√ßa t√©cnica, mentoria de equipes e um compromisso constante com a qualidade do c√≥digo e as melhores pr√°ticas de desenvolvimento.

## üõ†Ô∏è Expertise T√©cnica Principal

* **Linguagens:**
    * ![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=java&logoColor=white) 11, 17, profici√™ncia em programa√ß√£o concorrente e reativa.
* **Frameworks/Bibliotecas Backend:**
    * **Spring Ecosystem:**
        * ![Spring Boot](https://img.shields.io/badge/Spring_Boot-F2F4F9?style=for-the-badge&logo=spring-boot) Spring Boot (experi√™ncia avan√ßada em configura√ß√£o e otimiza√ß√£o),
        * ![Spring Cloud](https://img.shields.io/badge/Spring_Cloud-F2F4F9?style=for-the-badge&logo=spring-cloud) Spring Cloud (Service Discovery, Configuration Management, Gateway, Circuit Breakers, Stream),
        * ![Spring Security](https://img.shields.io/badge/Spring_Security-F2F4F9?style=for-the-badge&logo=spring-security) Spring Security (implementa√ß√£o de seguran√ßa com OAuth 2.0, JWT),
        * ![Spring Data JPA](https://img.shields.io/badge/Spring_Data_JPA-F2F4F9?style=for-the-badge&logo=spring-data-jpa) Spring Data JPA (otimiza√ß√£o de queries e estrat√©gias de persist√™ncia),
        * ![Lombok](https://img.shields.io/badge/Lombok-F2F4F9?style=for-the-badge&logo=projectlombok) Lombok.
    * **Persist√™ncia:**
        * ![JPA](https://img.shields.io/badge/JPA-F2F4F9?style=for-the-badge) JPA,
        * ![Flyway](https://img.shields.io/badge/Flyway-F2F4F9?style=for-the-badge&logo=flyway) Flyway (gerenciamento de migra√ß√µes de banco de dados).
    * **Mensageria:**
        * ![Apache Kafka](https://img.shields.io/badge/Apache_Kafka-000?style=for-the-badge&logo=apache-kafka) Kafka (arquitetura, streams, conectores),
        * ![RabbitMQ](https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white) RabbitMQ (roteamento avan√ßado, confiabilidade),
        * ![Google Cloud Pub/Sub](https://img.shields.io/badge/Google_Cloud_Pub/Sub-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%231E8E3E) Pub/Sub (GCP).
    * **Cache:**
        * ![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white) Redis (estrat√©gias de cache distribu√≠do).
    * **Comunica√ß√£o:**
        * ![gRPC](https://img.shields.io/badge/gRPC-F2F4F9?style=for-the-badge&logo=grpc) gRPC.
* **Testes:**
    * ![TDD](https://img.shields.io/badge/TDD-F2F4F9?style=for-the-badge) TDD (Desenvolvimento Guiado por Testes),
    * ![JUnit](https://img.shields.io/badge/JUnit-25A18E?style=for-the-badge&logo=junit5&logoColor=white) JUnit 4/5 (cria√ß√£o de testes unit√°rios abrangentes),
    * ![BDD](https://img.shields.io/badge/BDD-F2F4F9?style=for-the-badge) BDD (Desenvolvimento Orientado a Comportamento) com
    * ![Cucumber](https://img.shields.io/badge/Cucumber-232323?style=for-the-badge&logo=cucumber&logoColor=white) Cucumber (defini√ß√£o de cen√°rios em linguagem natural).
* **Cloud Computing:**
    * ![Amazon AWS](https://img.shields.io/badge/Amazon_AWS-232F3E?style=for-the-badge&logo=amazon-aws&logoColor=white) AWS (
        * ![Amazon SQS](https://img.shields.io/badge/Amazon_SQS-FF4F00?style=for-the-badge&logo=amazon-sqs&logoColor=white) SQS,
        * ![Amazon RDS](https://img.shields.io/badge/Amazon_RDS-0077B6?style=for-the-badge&logo=amazon-rds&logoColor=white) RDS,
        * ![Amazon SNS](https://img.shields.io/badge/Amazon_SNS-FF9900?style=for-the-badge&logo=amazon-sns&logoColor=white) SNS,
        * ![Amazon S3](https://img.shields.io/badge/Amazon_S3-569A31?style=for-the-badge&logo=amazon-s3&logoColor=white) S3,
        * ![Amazon ECR](https://img.shields.io/badge/Amazon_ECR-00AEEF?style=for-the-badge&logo=amazon-ecr&logoColor=white) ECR,
        * ![Amazon EKS](https://img.shields.io/badge/Amazon_EKS-000?style=for-the-badge&logo=amazon-eks&logoColor=white) EKS
    ),
    * ![Google Cloud](https://img.shields.io/badge/Google_Cloud-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white) GCP (
        * ![Google Cloud Functions](https://img.shields.io/badge/Google_Cloud_Functions-F2F4F9?style=for-the-badge&logo=google-cloud&logoColor=%23E91E63) Cloud Functions,
        * ![Google BigQuery](https://img.shields.io/badge/Google_BigQuery-F2F4F9?style=for-the-badge&logo=google-bigquery&logoColor=%234285F4) BigQuery
    ).
* **Containeriza√ß√£o e Orquestra√ß√£o:**
    * ![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white) Docker,
    * ![Kubernetes](https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=kubernetes&logoColor=white) Kubernetes.
* **Monitoramento e Observabilidade:**
    * ![Grafana](https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white) Grafana,
    * ![New Relic](https://img.shields.io/badge/New_Relic-00A63F?style=for-the-badge&logo=new-relic&logoColor=white) Relic,
    * ![Splunk](https://img.shields.io/badge/Splunk-000000?style=for-the-badge&logo=splunk&logoColor=white) Splunk.
* **CI/CD:**
    * ![Jenkins](https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white) Jenkins,
    * ![GitHub Actions](https://img.shields.io/badge/GitHub_Actions-2088FF?style=for-the-badge&logo=github-actions&logoColor=white) GitHub Actions,
    * ![GitLab CI](https://img.shields.io/badge/GitLab_CI-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab CI.
* **Frontend (Conhecimento):**
    * ![Angular](https://img.shields.io/badge/Angular-DD0031?style=for-the-badge&logo=angular&logoColor=white) Angular,
    * ![TypeScript](https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white) TypeScript.
* **Gerenciamento de C√≥digo:**
    * ![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white) Git,
    * ![GitLab](https://img.shields.io/badge/GitLab-FCA130?style=for-the-badge&logo=gitlab&logoColor=white) GitLab,
    * ![GitFlow](https://img.shields.io/badge/GitFlow-F2F4F9?style=for-the-badge) GitFlow.
* **Gerenciamento de Projetos:**
    * ![Jira](https://img.shields.io/badge/Jira-0052CC?style=for-the-badge&logo=jira&logoColor=white) Jira,
    * ![Scrum](https://img.shields.io/badge/Scrum-F2F4F9?style=for-the-badge) Scrum.

## üí° Experi√™ncia Profissional

Minha experi√™ncia abrange a lideran√ßa t√©cnica e a contribui√ß√£o individual em projetos complexos, incluindo:

* **Desenvolvimento e evolu√ß√£o de plataformas de microsservi√ßos** utilizando Spring Boot e Spring Cloud, garantindo alta escalabilidade e resili√™ncia.
* **Implementa√ß√£o de solu√ß√µes de mensageria robustas** com Kafka e RabbitMQ para comunica√ß√£o ass√≠ncrona e processamento de eventos em larga escala.
* **Desenvolvimento de APIs RESTful seguras e perform√°ticas** com Spring Security, seguindo as melhores pr√°ticas de design e documenta√ß√£o.
* **Utiliza√ß√£o extensiva de bancos de dados relacionais (JPA, Flyway) e NoSQL (Redis)**, com foco em otimiza√ß√£o de performance e modelagem de dados eficiente.
* **Implementa√ß√£o de testes automatizados em todas as camadas (unit√°rios, integra√ß√£o, BDD)** para garantir a qualidade e a estabilidade do software.
* **Experi√™ncia pr√°tica com plataformas de cloud (AWS e GCP)**, incluindo a utiliza√ß√£o de servi√ßos como SQS, RDS, SNS, S3, ECR, EKS, Cloud Functions e BigQuery.
* **Cria√ß√£o e gerenciamento de pipelines de CI/CD** com Jenkins e GitHub Actions para automatizar o processo de entrega de software.
* **Monitoramento e an√°lise de sistemas em produ√ß√£o** utilizando Grafana, Relic e Splunk para identificar e solucionar problemas proativamente.
* **Colabora√ß√£o em equipes multidisciplinares utilizando a metodologia Scrum e ferramentas como Jira.**
* **Mentoria de desenvolvedores juniores e plenos, compartilhando conhecimento e promovendo o crescimento t√©cnico.**

*(Aqui voc√™ pode adicionar detalhes mais espec√≠ficos sobre seus projetos e responsabilidades em cada experi√™ncia profissional, se desejar.)*

## üî≠ Projetos Pessoais e Contribui√ß√µes

* **[Nome do Projeto Pessoal 1](Link do Projeto 1):** Breve descri√ß√£o do projeto, destacando as tecnologias avan√ßadas utilizadas (ex: arquitetura reativa com Spring WebFlux e Kafka Streams).
* **[Nome do Projeto Pessoal 2](Link do Projeto 2):** Contribui√ß√£o significativa para algum projeto Open Source relevante em alguma das tecnologias listadas.
* **[Nome do Projeto Pessoal 3](Link do Projeto 3):** Demonstra√ß√£o de habilidades espec√≠ficas em alguma tecnologia (ex: implementa√ß√£o de um sistema de filas distribu√≠das com RabbitMQ com padr√µes de confiabilidade).

*(Inclua links para seus projetos mais relevantes no GitHub ou outras plataformas.)*

## ü§ù Conecte-se

* [LinkedIn](https://www.linkedin.com/in/maycon-araujo/)
* [GitHub](Seu Link do GitHub)
* [Seu Email Profissional]

## ‚ö° Interesses

* Explora√ß√£o de novas tecnologias e tend√™ncias no desenvolvimento de software.
* Participa√ß√£o em comunidades t√©cnicas e compartilhamento de conhecimento.
* Busca cont√≠nua por aprimoramento em arquiteturas de sistemas distribu√≠dos e escal√°veis.

Agrade√ßo o seu interesse em meu perfil. Estou sempre aberto a novas oportunidades e desafios que me permitam aplicar e expandir minhas habilidades. 

```kotlin
package com.c6bak.finappguaranteecardreceivables.test.utils

import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivableScheduleItem
import com.c6bak.finappguaranteecardreceivables.domain.entities.CardReceivablesSchedule
import com.c6bak.finappguaranteecardreceivables.domain.entities.enums.Register
import com.c6bak.finappguaranteecardreceivables.domain.entities.enums.Source
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import java.time.LocalDate
import java.time.LocalDateTime

object CardReceivablesScheduleTestUtils {
  fun buildDomain(
          id: String = "1",
          taxIdentifier: String = "12345678901234",
          register: String = "CERC",
          arrangement: String = "ARR",
          accreditor: String = "ACC",
          source: String = "ONLINE",
          startDate: LocalDate = LocalDate.of(2024, 1, 1),
          endDate: LocalDate = LocalDate.of(2024, 1, 31),
          schedules: List<CardReceivableScheduleItem> = emptyList(),
          createdAt: LocalDateTime = LocalDateTime.of(2024, 1, 1, 0, 0)
  ) =
          CardReceivablesSchedule(
                  id = id,
                  taxIdentifier = taxIdentifier,
                  register = register,
                  arrangement = arrangement,
                  accreditor = accreditor,
                  source = source,
                  startDate = startDate,
                  endDate = endDate,
                  schedules = schedules,
                  createdAt = createdAt
          )

  fun buildTable(
          id: String = "1",
          taxIdentifier: String = "12345678901234",
          register: Register = Register.CERC,
          arrangement: String = "ARR",
          accreditor: String = "ACC",
          source: Source = Source.ONLINE,
          startDate: LocalDate = LocalDate.of(2024, 1, 1),
          endDate: LocalDate = LocalDate.of(2024, 1, 31),
          schedules: List<CardReceivableScheduleItem> = emptyList(),
          createdAt: LocalDateTime = LocalDateTime.of(2024, 1, 1, 0, 0)
  ) =
          CardReceivablesScheduleTable(
                  id = id,
                  register = register.value,
                  arrangement = arrangement,
                  accreditor = accreditor,
                  source = source.value,
                  taxIdentifier = taxIdentifier,
                  startDate = startDate,
                  endDate = endDate,
                  schedules = schedules,
                  createdAt = createdAt
          )
}
package com.c6bak.finappguaranteecardreceivables.domain.dataaccess

import com.c6bak.finappguaranteecardreceivables.domain.dataaccess.filters.CardReceivablesScheduleFilters
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import io.mockk.mockk
import io.mockk.verify
import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Root
import java.time.LocalDate
import kotlin.test.assertNotNull
import org.junit.jupiter.api.Test

class CardReceivablesScheduleFiltersTest {

  @Test
  fun `byTaxIdentifier should create correct predicate`() {
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    val taxIdentifier = "12345678901234"
    val predicate =
            CardReceivablesScheduleFilters.byTaxIdentifier(taxIdentifier)
                    .toPredicate(root, query, cb)
    assertNotNull(predicate, "Predicate should not be null")
    verify { cb.equal(root.get<String>("taxIdentifier"), taxIdentifier) }
  }

  @Test
  fun `fromStartDate should create correct predicate`() {
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    val date = LocalDate.of(2024, 1, 1)
    val predicate = CardReceivablesScheduleFilters.fromStartDate(date).toPredicate(root, query, cb)
    assertNotNull(predicate, "Predicate should not be null")
    verify { cb.greaterThanOrEqualTo(root.get<LocalDate>("startDate"), date) }
  }

  @Test
  fun `untilEndDate should create correct predicate`() {
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    val date = LocalDate.of(2024, 2, 28)
    val predicate = CardReceivablesScheduleFilters.untilEndDate(date).toPredicate(root, query, cb)
    assertNotNull(predicate, "Predicate should not be null")
    verify { cb.lessThanOrEqualTo(root.get<LocalDate>("endDate"), date) }
  }

  @Test
  fun `byRootTaxIdentifier should create correct predicate`() {
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    val rootTaxIdentifier = "123456789"
    val predicate =
            CardReceivablesScheduleFilters.byRootTaxIdentifier(rootTaxIdentifier)
                    .toPredicate(root, query, cb)
    assertNotNull(predicate, "Predicate should not be null")
    verify { cb.like(root.get<String>("taxIdentifier"), "$rootTaxIdentifier%") }
  }

  @Test
  fun `composed filters should call all predicates`() {
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    val taxIdentifier = "12345678901234"
    val date = LocalDate.of(2024, 1, 1)
    val endDate = LocalDate.of(2024, 2, 28)
    val spec =
            CardReceivablesScheduleFilters.byTaxIdentifier(taxIdentifier)
                    .and(CardReceivablesScheduleFilters.fromStartDate(date))
                    .and(CardReceivablesScheduleFilters.untilEndDate(endDate))
    val predicate = spec.toPredicate(root, query, cb)
    assertNotNull(predicate, "Predicate should not be null")
    verify { cb.equal(root.get<String>("taxIdentifier"), taxIdentifier) }
    verify { cb.greaterThanOrEqualTo(root.get<LocalDate>("startDate"), date) }
    verify { cb.lessThanOrEqualTo(root.get<LocalDate>("endDate"), endDate) }
  }

  // Mant√©m os testes de assertNotNull para garantir cobertura b√°sica
  @Test
  fun `should create taxIdentifier filter`() {
    val taxIdentifier = "12345678901234"
    val filter = CardReceivablesScheduleFilters.byTaxIdentifier(taxIdentifier)
    assertNotNull(filter)
  }

  @Test
  fun `should create rootTaxIdentifier filter`() {
    val rootTaxIdentifier = "123456789"
    val filter = CardReceivablesScheduleFilters.byRootTaxIdentifier(rootTaxIdentifier)
    assertNotNull(filter)
  }

  @Test
  fun `should create startDate filter`() {
    val startDate = LocalDate.of(2024, 2, 1)
    val filter = CardReceivablesScheduleFilters.fromStartDate(startDate)
    assertNotNull(filter)
  }

  @Test
  fun `should create endDate filter`() {
    val endDate = LocalDate.of(2024, 2, 28)
    val filter = CardReceivablesScheduleFilters.untilEndDate(endDate)
    assertNotNull(filter)
  }

  @Test
  fun `should combine filters correctly`() {
    val taxIdentifier = "12345678901234"
    val startDate = LocalDate.of(2024, 2, 1)
    val endDate = LocalDate.of(2024, 2, 28)
    val combinedFilter =
            CardReceivablesScheduleFilters.byTaxIdentifier(taxIdentifier)
                    .and(CardReceivablesScheduleFilters.fromStartDate(startDate))
                    .and(CardReceivablesScheduleFilters.untilEndDate(endDate))
    assertNotNull(combinedFilter)
  }

  @Test
  fun `should handle edge cases in date filters`() {
    val startDate = LocalDate.of(2024, 2, 1)
    val endDate = LocalDate.of(2024, 2, 28)
    val startDateFilter = CardReceivablesScheduleFilters.fromStartDate(startDate)
    val endDateFilter = CardReceivablesScheduleFilters.untilEndDate(endDate)
    assertNotNull(startDateFilter)
    assertNotNull(endDateFilter)
  }
}

package com.c6bak.finappguaranteecardreceivables.domain.dataaccess

import com.c6bak.finappguaranteecardreceivables.dataaccess.CardReceivablesScheduleDataAccessImpl
import com.c6bak.finappguaranteecardreceivables.domain.entities.enums.Register
import com.c6bak.finappguaranteecardreceivables.domain.entities.enums.Source
import com.c6bak.finappguaranteecardreceivables.resources.repositories.CardReceivablesScheduleRepository
import com.c6bak.finappguaranteecardreceivables.resources.repositories.tables.CardReceivablesScheduleTable
import com.c6bak.finappguaranteecardreceivables.test.utils.CardReceivablesScheduleTestUtils
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import io.mockk.verify
import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Root
import java.time.LocalDate
import java.time.LocalDateTime
import kotlin.test.assertEquals
import kotlin.test.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.data.jpa.domain.Specification

class CardReceivablesScheduleDataAccessImplTest {
  private lateinit var repository: CardReceivablesScheduleRepository
  private lateinit var dataAccess: CardReceivablesScheduleDataAccessImpl

  companion object {
    const val DEFAULT_ID = "1"
    const val DEFAULT_TAX_IDENTIFIER = "12345678901234"
    const val DEFAULT_REGISTER = "CERC"
    const val DEFAULT_ARRANGEMENT = "ARR"
    const val DEFAULT_ACCREDITOR = "ACC"
    const val DEFAULT_SOURCE = "ONLINE"
    val DEFAULT_START_DATE: LocalDate = LocalDate.of(2024, 1, 1)
    val DEFAULT_END_DATE: LocalDate = LocalDate.of(2024, 1, 31)
    val DEFAULT_CREATED_AT: LocalDateTime = LocalDateTime.of(2024, 1, 1, 0, 0)
  }

  @BeforeEach
  fun setUp() {
    repository = mockk(relaxed = true)
    dataAccess = CardReceivablesScheduleDataAccessImpl(repository)
  }

  @Test
  fun `should find schedules by taxIdentifier with date filter`() {
    val startDate = LocalDate.of(2024, 2, 1)
    val endDate = LocalDate.of(2024, 2, 28)
    val tableEntities =
            listOf(
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "1",
                            startDate = LocalDate.of(2024, 1, 1),
                            endDate = LocalDate.of(2024, 1, 31)
                    ),
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "2",
                            startDate = startDate,
                            endDate = endDate
                    ),
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "3",
                            startDate = LocalDate.of(2024, 3, 1),
                            endDate = LocalDate.of(2024, 3, 31)
                    )
            )
    val specSlot = slot<Specification<CardReceivablesScheduleTable>>()
    every { repository.findAll(capture(specSlot)) } returns tableEntities
    val result = dataAccess.findSchedulesByTaxIdentifier(DEFAULT_TAX_IDENTIFIER, startDate, endDate)
    assertEquals(3, result.size)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
    assertTrue(specSlot.isCaptured)
    val spec = specSlot.captured
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    spec.toPredicate(root, query, cb)
    verify { cb.equal(root.get<String>("taxIdentifier"), DEFAULT_TAX_IDENTIFIER) }
    verify { cb.greaterThanOrEqualTo(root.get<LocalDate>("startDate"), startDate) }
    verify { cb.lessThanOrEqualTo(root.get<LocalDate>("endDate"), endDate) }
  }

  @Test
  fun `should find schedules by rootTaxIdentifier with date filter`() {
    val rootTaxIdentifier = "123456789"
    val startDate = LocalDate.of(2024, 4, 1)
    val endDate = LocalDate.of(2024, 4, 30)
    val tableEntities =
            listOf(
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "4",
                            taxIdentifier = "12345678901234",
                            startDate = startDate,
                            endDate = LocalDate.of(2024, 4, 15)
                    ),
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "5",
                            taxIdentifier = "12345678998765",
                            startDate = LocalDate.of(2024, 4, 10),
                            endDate = endDate
                    ),
                    CardReceivablesScheduleTestUtils.buildTable(
                            id = "6",
                            taxIdentifier = "98765432101234",
                            startDate = startDate,
                            endDate = endDate
                    )
            )
    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            tableEntities.filter { it.taxIdentifier.startsWith(rootTaxIdentifier) }
    val result = dataAccess.findSchedulesByRootTaxIdentifier(rootTaxIdentifier, startDate, endDate)
    assertEquals(2, result.size)
    assertTrue(result.all { it.taxIdentifier.startsWith(rootTaxIdentifier) })
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should save schedules correctly`() {
    val schedules =
            listOf(
                    CardReceivablesScheduleTestUtils.buildDomain(
                            id = "10",
                            taxIdentifier = "99999999999999"
                    )
            )
    every { repository.saveAll(any<List<CardReceivablesScheduleTable>>()) } returns listOf()
    dataAccess.saveSchedules(schedules)
    verify(exactly = 1) { repository.saveAll(any<List<CardReceivablesScheduleTable>>()) }
  }

  @Test
  fun `should apply correct filters when finding by taxIdentifier`() {
    val startDate = DEFAULT_START_DATE
    val endDate = DEFAULT_END_DATE
    val specSlot = slot<Specification<CardReceivablesScheduleTable>>()
    every { repository.findAll(capture(specSlot)) } returns emptyList()
    dataAccess.findSchedulesByTaxIdentifier(DEFAULT_TAX_IDENTIFIER, startDate, endDate)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
    assertTrue(specSlot.isCaptured)
    val spec = specSlot.captured
    val root = mockk<Root<CardReceivablesScheduleTable>>(relaxed = true)
    val query = mockk<CriteriaQuery<*>>(relaxed = true)
    val cb = mockk<CriteriaBuilder>(relaxed = true)
    spec.toPredicate(root, query, cb)
    verify { cb.equal(root.get<String>("taxIdentifier"), DEFAULT_TAX_IDENTIFIER) }
    verify { cb.greaterThanOrEqualTo(root.get<LocalDate>("startDate"), startDate) }
    verify { cb.lessThanOrEqualTo(root.get<LocalDate>("endDate"), endDate) }
  }

  @Test
  fun `should apply correct filters when finding by rootTaxIdentifier`() {
    val rootTaxIdentifier = "123456789"
    val startDate = DEFAULT_START_DATE
    val endDate = DEFAULT_END_DATE
    val specSlot = slot<Specification<CardReceivablesScheduleTable>>()
    every { repository.findAll(capture(specSlot)) } returns emptyList()
    dataAccess.findSchedulesByRootTaxIdentifier(rootTaxIdentifier, startDate, endDate)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
    assertTrue(specSlot.isCaptured)
  }

  @Test
  fun `should find schedules by composite key`() {
    val register = Register.CERC.value
    val arrangement = DEFAULT_ARRANGEMENT
    val accreditor = DEFAULT_ACCREDITOR
    val source = Source.ONLINE.value
    val taxIdentifier = DEFAULT_TAX_IDENTIFIER
    val matchingEntity =
            CardReceivablesScheduleTestUtils.buildTable(
                    id = "1",
                    taxIdentifier = taxIdentifier,
                    register = Register.CERC,
                    arrangement = arrangement,
                    accreditor = accreditor,
                    source = Source.ONLINE
            )
    every { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) } returns
            listOf(matchingEntity)
    val result =
            dataAccess.findByCompositeKey(register, arrangement, accreditor, source, taxIdentifier)
    assertEquals(1, result.size)
    assertEquals(taxIdentifier, result[0].taxIdentifier)
    assertEquals(register, result[0].register)
    assertEquals(arrangement, result[0].arrangement)
    assertEquals(accreditor, result[0].accreditor)
    assertEquals(source, result[0].source)
    verify(exactly = 1) { repository.findAll(any<Specification<CardReceivablesScheduleTable>>()) }
  }
}


```



